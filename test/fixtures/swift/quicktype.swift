// To parse the JSON, add this file to your project and do:
//
//   guard let topLevel = try TopLevel(json) else { ... }

import Foundation

class TopLevel: Codable {
    let abranchiata: [Abranchiata]
    let academe: [Academe]
    let acquirable: [Acquirable]
    let aerometry: [Aerometry]
    let alexin: [Alexin]
    let alleviate: [Alleviate]
    let amaas: [Amaa]
    let ambassage: [Ambassage]
    let amphithyron: [Amphithyron?]
    let andriana: [String?]
    let ankee: [Ankee]
    let annihilator: [[String: Int?]?]
    let annulose: JSONNull?
    let ansarie: [Ansarie]
    let aphasia: [Aphasia]
    let asprawl: [Asprawl]
    let attractive: [Bool?]
    let barksome: [String: Int]
    let bedesman: [Bedesman]
    let belard: [Belard]
    let bocking: [Bocking]
    let brawlingly: [Brawlingly]
    let brookie: [Brookie]
    let bumboatman: [Bumboatman]
    let bystreet: [JSONNull?]
    let calaverite: [Calaverite]
    let catallactic: [Catallactic]
    let cemental: [Cemental]
    let centrodesmose: String
    let cerograph: [Cerograph]
    let chemotherapeutics: [ChemotherapeuticUnion]
    let chytridiaceae: [Chytridiaceae]
    let cimelia: [Cimelia]
    let citrated: Int
    let clinodome: [Asprawl]
    let coadjust: [CoadjustUnion]
    let consilience: [Consilience]
    let constructor: [Constructor]
    let continuative: [Continuative]
    let credulity: [Credulity]
    let creviced: [Creviced]
    let cubiculum: [[Int?]]
    let deruralize: [Deruralize]
    let diaereses: [Diaerese]
    let discordia: [DiscordiaUnion]
    let dissolution: [[JSONNull?]?]
    let downstroke: [Downstroke]
    let electrotautomerism: [Double?]
    let eleutheromania: [Eleutheromania]
    let encrust: [String: JSONNull?]
    let endomyces: [Endomyce]
    let entomoid: [Entomoid]
    let epinephelidae: [Epinephelidae]
    let epipaleolithic: [Epipaleolithic]
    let eupatorium: [Eupatorium]
    let expropriable: [Expropriable]
    let faggingly: [Faggingly]
    let fenks: [Fenk]
    let flagmaking: [Flagmaking]
    let fluorometer: [Fluorometer]
    let fulsome: [Int?]
    let fuzzy: [Fuzzy]
    let gardenwards: [Gardenward]
    let generalissimo: [Generalissimo]
    let gryphosaurus: [Gryphosaurus]
    let habeas: [[String: Int]?]
    let hemicrystalline: [Hemicrystalline]
    let hemocoele: [HemocoeleUnion]
    let hoister: [Hoister]
    let hyperpiesis: [Hyperpiesi]
    let hyppish: [Hyppish]
    let idealizer: [Idealizer]
    let incrustator: [Incrustator]
    let intentiveness: [Intentiveness]
    let interacinar: Interacinar
    let intercorrelation: [[Int]?]
    let jacutinga: [Jacutinga]
    let juror: [Juror]
    let kongoni: [Kongoni]
    let koryak: [Koryak]
    let ladronism: [Ladronism]
    let landlubberly: [Landlubberly]
    let lavinia: [LaviniaUnion]
    let listener: [Listener]
    let lupus: [LupusUnion]
    let maslin: [Maslin]
    let monazite: [Monazite]
    let monoliteral: [Monoliteral]
    let monotheistically: [MonotheisticallyUnion]
    let montage: [Montage]
    let moralness: [Moralness]
    let mowra: [RebeccaClass?]
    let mulishly: [Mulishly]
    let myoscope: [Myoscope]
    let nach: [[Int?]?]
    let neuromastic: [Neuromastic]
    let noncontributing: [Noncontributing]
    let nonnervous: [Nonnervous]
    let nonvaluation: [Nonvaluation]
    let occupationalist: [Occupationalist]
    let oskar: [Oskar]
    let outrival: [Outrival]
    let paleographically: [Paleographically]
    let pamphletwise: [Pamphletwise]
    let pediatrics: [Pediatric]
    let perceptive: [Bool]
    let piaculum: [PiaculumUnion]
    let piccadilly: [Piccadilly]
    let piffler: [Piffler]
    let pithful: [Pithful]
    let placuntitis: [Placuntiti]
    let plectopterous: [Consilience]
    let pneumocele: [Pneumocele?]
    let poliorcetic: [Poliorcetic]
    let poormaster: [Poormaster]
    let potwhisky: [Potwhisky]
    let practicalizer: [Practicalizer]
    let prefreshman: [Prefreshman]
    let prehensility: [Prehensility]
    let prevoidance: [Prevoidance]
    let probant: [[String: Int?]]
    let protext: [Protext]
    let protrusive: [Protrusive]
    let pulpitism: [Pulpitism]
    let pyodermia: [Pyodermia]
    let quebrachine: [Quebrachine]
    let querier: [Querier]
    let rebarbative: [Rebarbative]
    let rebecca: [RebeccaUnion]
    let reimagine: [Reimagine]
    let ressaut: [String: String]
    let retrocervical: [Retrocervical]
    let revert: [Revert]
    let rewrite: [Rewrite]
    let rhomboganoidei: [Rhomboganoidei]
    let rigsmal: Bool
    let ruellia: [Ruellia]
    let saccoderm: [Saccoderm]
    let santir: [Faggingly]
    let saprophilous: [Saprophilous]
    let saxten: [SaxtenUnion]
    let scatty: [[String: JSONNull?]?]
    let school: [School]
    let scoffer: [Scoffer]
    let scrampum: [Scrampum]
    let semantic: Double
    let serpentinic: [Epipaleolithic]
    let shadowable: [Shadowable]
    let shakespearolater: [Shakespearolater]
    let sistering: [Sistering]
    let staghunting: [Staghunting]
    let stagmometer: [Stagmometer]
    let stimulability: [Stimulability]
    let strangleable: [Neuromastic]
    let strenuosity: [StrenuosityUnion]
    let svan: [Double]
    let tabaxir: [Aerometry]
    let talpiform: [Talpiform]
    let thwack: [Thwack]
    let to: [Double?]
    let tortricine: [Tortricine]
    let truantcy: [TruantcyUnion]
    let turgesce: [String]
    let unbeginning: [Unbeginning]
    let underdunged: [Double]
    let undesirability: [Undesirability]
    let unerasing: [Unerasing]
    let unguentarium: [Unguentarium]
    let unimpeachably: [UnimpeachablyUnion]
    let unmortgaged: [Unmortgaged]
    let unobstructed: [Unobstructed]
    let unreceptivity: [Unreceptivity]
    let unsatisfactoriness: [Unsatisfactoriness]
    let unsecurity: [Int]
    let unstressed: [Unstressed]
    let untasked: [Untasked]
    let unvarying: [Unvarying]
    let vehemently: [Vehemently]
    let warriorship: [String: Bool]
    let wayao: [String: Double]
    let whitepot: [Monazite]
    let wrothy: [Wrothy]

    enum CodingKeys: String, CodingKey {
        case abranchiata = "Abranchiata"
        case academe, acquirable, aerometry, alexin, alleviate, amaas, ambassage, amphithyron
        case andriana = "Andriana"
        case ankee, annihilator, annulose
        case ansarie = "Ansarie"
        case aphasia, asprawl, attractive, barksome, bedesman, belard, bocking, brawlingly, brookie, bumboatman, bystreet, calaverite, catallactic, cemental, centrodesmose, cerograph, chemotherapeutics
        case chytridiaceae = "Chytridiaceae"
        case cimelia, citrated, clinodome, coadjust, consilience, constructor, continuative, credulity, creviced, cubiculum, deruralize, diaereses
        case discordia = "Discordia"
        case dissolution, downstroke, electrotautomerism, eleutheromania, encrust
        case endomyces = "Endomyces"
        case entomoid
        case epinephelidae = "Epinephelidae"
        case epipaleolithic
        case eupatorium = "Eupatorium"
        case expropriable, faggingly, fenks, flagmaking, fluorometer, fulsome, fuzzy, gardenwards, generalissimo
        case gryphosaurus = "Gryphosaurus"
        case habeas, hemicrystalline, hemocoele, hoister, hyperpiesis, hyppish, idealizer, incrustator, intentiveness, interacinar, intercorrelation, jacutinga, juror, kongoni
        case koryak = "Koryak"
        case ladronism, landlubberly
        case lavinia = "Lavinia"
        case listener, lupus, maslin, monazite, monoliteral, monotheistically, montage, moralness, mowra, mulishly, myoscope, nach, neuromastic, noncontributing, nonnervous, nonvaluation, occupationalist
        case oskar = "Oskar"
        case outrival, paleographically, pamphletwise, pediatrics, perceptive, piaculum, piccadilly, piffler, pithful, placuntitis, plectopterous, pneumocele, poliorcetic, poormaster, potwhisky, practicalizer, prefreshman, prehensility, prevoidance, probant, protext, protrusive, pulpitism, pyodermia, quebrachine, querier, rebarbative
        case rebecca = "Rebecca"
        case reimagine, ressaut, retrocervical, revert, rewrite
        case rhomboganoidei = "Rhomboganoidei"
        case rigsmal = "Rigsmal"
        case ruellia = "Ruellia"
        case saccoderm, santir, saprophilous, saxten, scatty
        case school = "School"
        case scoffer, scrampum, semantic, serpentinic, shadowable
        case shakespearolater = "Shakespearolater"
        case sistering, staghunting, stagmometer, stimulability, strangleable, strenuosity
        case svan = "Svan"
        case tabaxir, talpiform, thwack, to, tortricine, truantcy, turgesce, unbeginning, underdunged, undesirability, unerasing, unguentarium, unimpeachably, unmortgaged, unobstructed, unreceptivity, unsatisfactoriness, unsecurity, unstressed, untasked, unvarying, vehemently, warriorship
        case wayao = "Wayao"
        case whitepot, wrothy
    }

    init(abranchiata: [Abranchiata], academe: [Academe], acquirable: [Acquirable], aerometry: [Aerometry], alexin: [Alexin], alleviate: [Alleviate], amaas: [Amaa], ambassage: [Ambassage], amphithyron: [Amphithyron?], andriana: [String?], ankee: [Ankee], annihilator: [[String: Int?]?], annulose: JSONNull?, ansarie: [Ansarie], aphasia: [Aphasia], asprawl: [Asprawl], attractive: [Bool?], barksome: [String: Int], bedesman: [Bedesman], belard: [Belard], bocking: [Bocking], brawlingly: [Brawlingly], brookie: [Brookie], bumboatman: [Bumboatman], bystreet: [JSONNull?], calaverite: [Calaverite], catallactic: [Catallactic], cemental: [Cemental], centrodesmose: String, cerograph: [Cerograph], chemotherapeutics: [ChemotherapeuticUnion], chytridiaceae: [Chytridiaceae], cimelia: [Cimelia], citrated: Int, clinodome: [Asprawl], coadjust: [CoadjustUnion], consilience: [Consilience], constructor: [Constructor], continuative: [Continuative], credulity: [Credulity], creviced: [Creviced], cubiculum: [[Int?]], deruralize: [Deruralize], diaereses: [Diaerese], discordia: [DiscordiaUnion], dissolution: [[JSONNull?]?], downstroke: [Downstroke], electrotautomerism: [Double?], eleutheromania: [Eleutheromania], encrust: [String: JSONNull?], endomyces: [Endomyce], entomoid: [Entomoid], epinephelidae: [Epinephelidae], epipaleolithic: [Epipaleolithic], eupatorium: [Eupatorium], expropriable: [Expropriable], faggingly: [Faggingly], fenks: [Fenk], flagmaking: [Flagmaking], fluorometer: [Fluorometer], fulsome: [Int?], fuzzy: [Fuzzy], gardenwards: [Gardenward], generalissimo: [Generalissimo], gryphosaurus: [Gryphosaurus], habeas: [[String: Int]?], hemicrystalline: [Hemicrystalline], hemocoele: [HemocoeleUnion], hoister: [Hoister], hyperpiesis: [Hyperpiesi], hyppish: [Hyppish], idealizer: [Idealizer], incrustator: [Incrustator], intentiveness: [Intentiveness], interacinar: Interacinar, intercorrelation: [[Int]?], jacutinga: [Jacutinga], juror: [Juror], kongoni: [Kongoni], koryak: [Koryak], ladronism: [Ladronism], landlubberly: [Landlubberly], lavinia: [LaviniaUnion], listener: [Listener], lupus: [LupusUnion], maslin: [Maslin], monazite: [Monazite], monoliteral: [Monoliteral], monotheistically: [MonotheisticallyUnion], montage: [Montage], moralness: [Moralness], mowra: [RebeccaClass?], mulishly: [Mulishly], myoscope: [Myoscope], nach: [[Int?]?], neuromastic: [Neuromastic], noncontributing: [Noncontributing], nonnervous: [Nonnervous], nonvaluation: [Nonvaluation], occupationalist: [Occupationalist], oskar: [Oskar], outrival: [Outrival], paleographically: [Paleographically], pamphletwise: [Pamphletwise], pediatrics: [Pediatric], perceptive: [Bool], piaculum: [PiaculumUnion], piccadilly: [Piccadilly], piffler: [Piffler], pithful: [Pithful], placuntitis: [Placuntiti], plectopterous: [Consilience], pneumocele: [Pneumocele?], poliorcetic: [Poliorcetic], poormaster: [Poormaster], potwhisky: [Potwhisky], practicalizer: [Practicalizer], prefreshman: [Prefreshman], prehensility: [Prehensility], prevoidance: [Prevoidance], probant: [[String: Int?]], protext: [Protext], protrusive: [Protrusive], pulpitism: [Pulpitism], pyodermia: [Pyodermia], quebrachine: [Quebrachine], querier: [Querier], rebarbative: [Rebarbative], rebecca: [RebeccaUnion], reimagine: [Reimagine], ressaut: [String: String], retrocervical: [Retrocervical], revert: [Revert], rewrite: [Rewrite], rhomboganoidei: [Rhomboganoidei], rigsmal: Bool, ruellia: [Ruellia], saccoderm: [Saccoderm], santir: [Faggingly], saprophilous: [Saprophilous], saxten: [SaxtenUnion], scatty: [[String: JSONNull?]?], school: [School], scoffer: [Scoffer], scrampum: [Scrampum], semantic: Double, serpentinic: [Epipaleolithic], shadowable: [Shadowable], shakespearolater: [Shakespearolater], sistering: [Sistering], staghunting: [Staghunting], stagmometer: [Stagmometer], stimulability: [Stimulability], strangleable: [Neuromastic], strenuosity: [StrenuosityUnion], svan: [Double], tabaxir: [Aerometry], talpiform: [Talpiform], thwack: [Thwack], to: [Double?], tortricine: [Tortricine], truantcy: [TruantcyUnion], turgesce: [String], unbeginning: [Unbeginning], underdunged: [Double], undesirability: [Undesirability], unerasing: [Unerasing], unguentarium: [Unguentarium], unimpeachably: [UnimpeachablyUnion], unmortgaged: [Unmortgaged], unobstructed: [Unobstructed], unreceptivity: [Unreceptivity], unsatisfactoriness: [Unsatisfactoriness], unsecurity: [Int], unstressed: [Unstressed], untasked: [Untasked], unvarying: [Unvarying], vehemently: [Vehemently], warriorship: [String: Bool], wayao: [String: Double], whitepot: [Monazite], wrothy: [Wrothy]) {
        self.abranchiata = abranchiata
        self.academe = academe
        self.acquirable = acquirable
        self.aerometry = aerometry
        self.alexin = alexin
        self.alleviate = alleviate
        self.amaas = amaas
        self.ambassage = ambassage
        self.amphithyron = amphithyron
        self.andriana = andriana
        self.ankee = ankee
        self.annihilator = annihilator
        self.annulose = annulose
        self.ansarie = ansarie
        self.aphasia = aphasia
        self.asprawl = asprawl
        self.attractive = attractive
        self.barksome = barksome
        self.bedesman = bedesman
        self.belard = belard
        self.bocking = bocking
        self.brawlingly = brawlingly
        self.brookie = brookie
        self.bumboatman = bumboatman
        self.bystreet = bystreet
        self.calaverite = calaverite
        self.catallactic = catallactic
        self.cemental = cemental
        self.centrodesmose = centrodesmose
        self.cerograph = cerograph
        self.chemotherapeutics = chemotherapeutics
        self.chytridiaceae = chytridiaceae
        self.cimelia = cimelia
        self.citrated = citrated
        self.clinodome = clinodome
        self.coadjust = coadjust
        self.consilience = consilience
        self.constructor = constructor
        self.continuative = continuative
        self.credulity = credulity
        self.creviced = creviced
        self.cubiculum = cubiculum
        self.deruralize = deruralize
        self.diaereses = diaereses
        self.discordia = discordia
        self.dissolution = dissolution
        self.downstroke = downstroke
        self.electrotautomerism = electrotautomerism
        self.eleutheromania = eleutheromania
        self.encrust = encrust
        self.endomyces = endomyces
        self.entomoid = entomoid
        self.epinephelidae = epinephelidae
        self.epipaleolithic = epipaleolithic
        self.eupatorium = eupatorium
        self.expropriable = expropriable
        self.faggingly = faggingly
        self.fenks = fenks
        self.flagmaking = flagmaking
        self.fluorometer = fluorometer
        self.fulsome = fulsome
        self.fuzzy = fuzzy
        self.gardenwards = gardenwards
        self.generalissimo = generalissimo
        self.gryphosaurus = gryphosaurus
        self.habeas = habeas
        self.hemicrystalline = hemicrystalline
        self.hemocoele = hemocoele
        self.hoister = hoister
        self.hyperpiesis = hyperpiesis
        self.hyppish = hyppish
        self.idealizer = idealizer
        self.incrustator = incrustator
        self.intentiveness = intentiveness
        self.interacinar = interacinar
        self.intercorrelation = intercorrelation
        self.jacutinga = jacutinga
        self.juror = juror
        self.kongoni = kongoni
        self.koryak = koryak
        self.ladronism = ladronism
        self.landlubberly = landlubberly
        self.lavinia = lavinia
        self.listener = listener
        self.lupus = lupus
        self.maslin = maslin
        self.monazite = monazite
        self.monoliteral = monoliteral
        self.monotheistically = monotheistically
        self.montage = montage
        self.moralness = moralness
        self.mowra = mowra
        self.mulishly = mulishly
        self.myoscope = myoscope
        self.nach = nach
        self.neuromastic = neuromastic
        self.noncontributing = noncontributing
        self.nonnervous = nonnervous
        self.nonvaluation = nonvaluation
        self.occupationalist = occupationalist
        self.oskar = oskar
        self.outrival = outrival
        self.paleographically = paleographically
        self.pamphletwise = pamphletwise
        self.pediatrics = pediatrics
        self.perceptive = perceptive
        self.piaculum = piaculum
        self.piccadilly = piccadilly
        self.piffler = piffler
        self.pithful = pithful
        self.placuntitis = placuntitis
        self.plectopterous = plectopterous
        self.pneumocele = pneumocele
        self.poliorcetic = poliorcetic
        self.poormaster = poormaster
        self.potwhisky = potwhisky
        self.practicalizer = practicalizer
        self.prefreshman = prefreshman
        self.prehensility = prehensility
        self.prevoidance = prevoidance
        self.probant = probant
        self.protext = protext
        self.protrusive = protrusive
        self.pulpitism = pulpitism
        self.pyodermia = pyodermia
        self.quebrachine = quebrachine
        self.querier = querier
        self.rebarbative = rebarbative
        self.rebecca = rebecca
        self.reimagine = reimagine
        self.ressaut = ressaut
        self.retrocervical = retrocervical
        self.revert = revert
        self.rewrite = rewrite
        self.rhomboganoidei = rhomboganoidei
        self.rigsmal = rigsmal
        self.ruellia = ruellia
        self.saccoderm = saccoderm
        self.santir = santir
        self.saprophilous = saprophilous
        self.saxten = saxten
        self.scatty = scatty
        self.school = school
        self.scoffer = scoffer
        self.scrampum = scrampum
        self.semantic = semantic
        self.serpentinic = serpentinic
        self.shadowable = shadowable
        self.shakespearolater = shakespearolater
        self.sistering = sistering
        self.staghunting = staghunting
        self.stagmometer = stagmometer
        self.stimulability = stimulability
        self.strangleable = strangleable
        self.strenuosity = strenuosity
        self.svan = svan
        self.tabaxir = tabaxir
        self.talpiform = talpiform
        self.thwack = thwack
        self.to = to
        self.tortricine = tortricine
        self.truantcy = truantcy
        self.turgesce = turgesce
        self.unbeginning = unbeginning
        self.underdunged = underdunged
        self.undesirability = undesirability
        self.unerasing = unerasing
        self.unguentarium = unguentarium
        self.unimpeachably = unimpeachably
        self.unmortgaged = unmortgaged
        self.unobstructed = unobstructed
        self.unreceptivity = unreceptivity
        self.unsatisfactoriness = unsatisfactoriness
        self.unsecurity = unsecurity
        self.unstressed = unstressed
        self.untasked = untasked
        self.unvarying = unvarying
        self.vehemently = vehemently
        self.warriorship = warriorship
        self.wayao = wayao
        self.whitepot = whitepot
        self.wrothy = wrothy
    }
}

enum Abranchiata: Codable {
    case integer(Int)
    case integerArray([Int])
    case null

    init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let x = try? container.decode(Int.self) {
            self = .integer(x)
            return
        }
        if let x = try? container.decode([Int].self) {
            self = .integerArray(x)
            return
        }
        if container.decodeNil() {
            self = .null
            return
        }
        throw DecodingError.typeMismatch(Abranchiata.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Wrong type for Abranchiata"))
    }

    func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case .integer(let x):
            try container.encode(x)
        case .integerArray(let x):
            try container.encode(x)
        case .null:
            try container.encodeNil()
        }
    }
}

enum Academe: Codable {
    case integer(Int)
    case integerArray([Int])
    case integerMap([String: Int])

    init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let x = try? container.decode(Int.self) {
            self = .integer(x)
            return
        }
        if let x = try? container.decode([String: Int].self) {
            self = .integerMap(x)
            return
        }
        if let x = try? container.decode([Int].self) {
            self = .integerArray(x)
            return
        }
        throw DecodingError.typeMismatch(Academe.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Wrong type for Academe"))
    }

    func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case .integer(let x):
            try container.encode(x)
        case .integerArray(let x):
            try container.encode(x)
        case .integerMap(let x):
            try container.encode(x)
        }
    }
}

enum Acquirable: Codable {
    case integerMap([String: Int])
    case unionArray([Int?])

    init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let x = try? container.decode([String: Int].self) {
            self = .integerMap(x)
            return
        }
        if let x = try? container.decode([Int?].self) {
            self = .unionArray(x)
            return
        }
        throw DecodingError.typeMismatch(Acquirable.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Wrong type for Acquirable"))
    }

    func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case .integerMap(let x):
            try container.encode(x)
        case .unionArray(let x):
            try container.encode(x)
        }
    }
}

enum Aerometry: Codable {
    case bool(Bool)
    case double(Double)

    init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let x = try? container.decode(Bool.self) {
            self = .bool(x)
            return
        }
        if let x = try? container.decode(Double.self) {
            self = .double(x)
            return
        }
        throw DecodingError.typeMismatch(Aerometry.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Wrong type for Aerometry"))
    }

    func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case .bool(let x):
            try container.encode(x)
        case .double(let x):
            try container.encode(x)
        }
    }
}

enum Alexin: Codable {
    case bool(Bool)
    case integerArray([Int])

    init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let x = try? container.decode(Bool.self) {
            self = .bool(x)
            return
        }
        if let x = try? container.decode([Int].self) {
            self = .integerArray(x)
            return
        }
        throw DecodingError.typeMismatch(Alexin.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Wrong type for Alexin"))
    }

    func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case .bool(let x):
            try container.encode(x)
        case .integerArray(let x):
            try container.encode(x)
        }
    }
}

enum Alleviate: Codable {
    case nullMap([String: JSONNull?])
    case unionArray([Int?])

    init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let x = try? container.decode([String: JSONNull?].self) {
            self = .nullMap(x)
            return
        }
        if let x = try? container.decode([Int?].self) {
            self = .unionArray(x)
            return
        }
        throw DecodingError.typeMismatch(Alleviate.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Wrong type for Alleviate"))
    }

    func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case .nullMap(let x):
            try container.encode(x)
        case .unionArray(let x):
            try container.encode(x)
        }
    }
}

enum Amaa: Codable {
    case bool(Bool)
    case integer(Int)
    case rebeccaClass(RebeccaClass)

    init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let x = try? container.decode(Bool.self) {
            self = .bool(x)
            return
        }
        if let x = try? container.decode(Int.self) {
            self = .integer(x)
            return
        }
        if let x = try? container.decode(RebeccaClass.self) {
            self = .rebeccaClass(x)
            return
        }
        throw DecodingError.typeMismatch(Amaa.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Wrong type for Amaa"))
    }

    func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case .bool(let x):
            try container.encode(x)
        case .integer(let x):
            try container.encode(x)
        case .rebeccaClass(let x):
            try container.encode(x)
        }
    }
}

class RebeccaClass: Codable {
    let catharticalness: Double
    let chirotherium: Int
    let disdiapason: String
    let homocerc: Bool
    let nonbookish: JSONNull?

    enum CodingKeys: String, CodingKey {
        case catharticalness
        case chirotherium = "Chirotherium"
        case disdiapason, homocerc, nonbookish
    }

    init(catharticalness: Double, chirotherium: Int, disdiapason: String, homocerc: Bool, nonbookish: JSONNull?) {
        self.catharticalness = catharticalness
        self.chirotherium = chirotherium
        self.disdiapason = disdiapason
        self.homocerc = homocerc
        self.nonbookish = nonbookish
    }
}

enum Ambassage: Codable {
    case nullArray([JSONNull?])
    case string(String)

    init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let x = try? container.decode(String.self) {
            self = .string(x)
            return
        }
        if let x = try? container.decode([JSONNull?].self) {
            self = .nullArray(x)
            return
        }
        throw DecodingError.typeMismatch(Ambassage.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Wrong type for Ambassage"))
    }

    func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case .nullArray(let x):
            try container.encode(x)
        case .string(let x):
            try container.encode(x)
        }
    }
}

class Amphithyron: Codable {
    let akroasis, antiphonical, basebred: Int?
    let catharticalness: Double?
    let chirotherium, conductometric: Int?
    let disdiapason: String?
    let ensilation, eyebolt, fistulated, heteropod: Int?
    let homocerc: Bool?
    let juniperus, labyrinthically, martyrization, mispolicy: Int?
    let multipara, nazirite: Int?
    let nonbookish: JSONNull?
    let possessorial, shamed, shelfworn, stagnum: Int?
    let those, undecimal: Int?

    enum CodingKeys: String, CodingKey {
        case akroasis, antiphonical, basebred, catharticalness
        case chirotherium = "Chirotherium"
        case conductometric, disdiapason, ensilation, eyebolt, fistulated, heteropod, homocerc
        case juniperus = "Juniperus"
        case labyrinthically, martyrization, mispolicy, multipara
        case nazirite = "Nazirite"
        case nonbookish, possessorial, shamed, shelfworn, stagnum
        case those = "Those"
        case undecimal
    }

    init(akroasis: Int?, antiphonical: Int?, basebred: Int?, catharticalness: Double?, chirotherium: Int?, conductometric: Int?, disdiapason: String?, ensilation: Int?, eyebolt: Int?, fistulated: Int?, heteropod: Int?, homocerc: Bool?, juniperus: Int?, labyrinthically: Int?, martyrization: Int?, mispolicy: Int?, multipara: Int?, nazirite: Int?, nonbookish: JSONNull?, possessorial: Int?, shamed: Int?, shelfworn: Int?, stagnum: Int?, those: Int?, undecimal: Int?) {
        self.akroasis = akroasis
        self.antiphonical = antiphonical
        self.basebred = basebred
        self.catharticalness = catharticalness
        self.chirotherium = chirotherium
        self.conductometric = conductometric
        self.disdiapason = disdiapason
        self.ensilation = ensilation
        self.eyebolt = eyebolt
        self.fistulated = fistulated
        self.heteropod = heteropod
        self.homocerc = homocerc
        self.juniperus = juniperus
        self.labyrinthically = labyrinthically
        self.martyrization = martyrization
        self.mispolicy = mispolicy
        self.multipara = multipara
        self.nazirite = nazirite
        self.nonbookish = nonbookish
        self.possessorial = possessorial
        self.shamed = shamed
        self.shelfworn = shelfworn
        self.stagnum = stagnum
        self.those = those
        self.undecimal = undecimal
    }
}

enum Ankee: Codable {
    case integer(Int)
    case integerArray([Int])
    case nullMap([String: JSONNull?])

    init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let x = try? container.decode(Int.self) {
            self = .integer(x)
            return
        }
        if let x = try? container.decode([String: JSONNull?].self) {
            self = .nullMap(x)
            return
        }
        if let x = try? container.decode([Int].self) {
            self = .integerArray(x)
            return
        }
        throw DecodingError.typeMismatch(Ankee.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Wrong type for Ankee"))
    }

    func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case .integer(let x):
            try container.encode(x)
        case .integerArray(let x):
            try container.encode(x)
        case .nullMap(let x):
            try container.encode(x)
        }
    }
}

enum Ansarie: Codable {
    case integerArray([Int])
    case nullMap([String: JSONNull?])
    case null

    init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let x = try? container.decode([String: JSONNull?].self) {
            self = .nullMap(x)
            return
        }
        if let x = try? container.decode([Int].self) {
            self = .integerArray(x)
            return
        }
        if container.decodeNil() {
            self = .null
            return
        }
        throw DecodingError.typeMismatch(Ansarie.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Wrong type for Ansarie"))
    }

    func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case .integerArray(let x):
            try container.encode(x)
        case .nullMap(let x):
            try container.encode(x)
        case .null:
            try container.encodeNil()
        }
    }
}

enum Aphasia: Codable {
    case integer(Int)
    case integerArray([Int])

    init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let x = try? container.decode(Int.self) {
            self = .integer(x)
            return
        }
        if let x = try? container.decode([Int].self) {
            self = .integerArray(x)
            return
        }
        throw DecodingError.typeMismatch(Aphasia.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Wrong type for Aphasia"))
    }

    func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case .integer(let x):
            try container.encode(x)
        case .integerArray(let x):
            try container.encode(x)
        }
    }
}

enum Asprawl: Codable {
    case double(Double)
    case string(String)

    init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let x = try? container.decode(Double.self) {
            self = .double(x)
            return
        }
        if let x = try? container.decode(String.self) {
            self = .string(x)
            return
        }
        throw DecodingError.typeMismatch(Asprawl.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Wrong type for Asprawl"))
    }

    func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case .double(let x):
            try container.encode(x)
        case .string(let x):
            try container.encode(x)
        }
    }
}

enum Bedesman: Codable {
    case bool(Bool)
    case double(Double)
    case string(String)

    init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let x = try? container.decode(Bool.self) {
            self = .bool(x)
            return
        }
        if let x = try? container.decode(Double.self) {
            self = .double(x)
            return
        }
        if let x = try? container.decode(String.self) {
            self = .string(x)
            return
        }
        throw DecodingError.typeMismatch(Bedesman.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Wrong type for Bedesman"))
    }

    func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case .bool(let x):
            try container.encode(x)
        case .double(let x):
            try container.encode(x)
        case .string(let x):
            try container.encode(x)
        }
    }
}

enum Belard: Codable {
    case double(Double)
    case integerArray([Int])
    case rebeccaClass(RebeccaClass)

    init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let x = try? container.decode(Double.self) {
            self = .double(x)
            return
        }
        if let x = try? container.decode(RebeccaClass.self) {
            self = .rebeccaClass(x)
            return
        }
        if let x = try? container.decode([Int].self) {
            self = .integerArray(x)
            return
        }
        throw DecodingError.typeMismatch(Belard.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Wrong type for Belard"))
    }

    func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case .double(let x):
            try container.encode(x)
        case .integerArray(let x):
            try container.encode(x)
        case .rebeccaClass(let x):
            try container.encode(x)
        }
    }
}

enum Bocking: Codable {
    case bool(Bool)
    case integerArray([Int])
    case integerMap([String: Int])

    init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let x = try? container.decode(Bool.self) {
            self = .bool(x)
            return
        }
        if let x = try? container.decode([String: Int].self) {
            self = .integerMap(x)
            return
        }
        if let x = try? container.decode([Int].self) {
            self = .integerArray(x)
            return
        }
        throw DecodingError.typeMismatch(Bocking.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Wrong type for Bocking"))
    }

    func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case .bool(let x):
            try container.encode(x)
        case .integerArray(let x):
            try container.encode(x)
        case .integerMap(let x):
            try container.encode(x)
        }
    }
}

enum Brawlingly: Codable {
    case nullArray([JSONNull?])
    case unionMap([String: Int?])

    init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let x = try? container.decode([String: Int?].self) {
            self = .unionMap(x)
            return
        }
        if let x = try? container.decode([JSONNull?].self) {
            self = .nullArray(x)
            return
        }
        throw DecodingError.typeMismatch(Brawlingly.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Wrong type for Brawlingly"))
    }

    func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case .nullArray(let x):
            try container.encode(x)
        case .unionMap(let x):
            try container.encode(x)
        }
    }
}

enum Brookie: Codable {
    case integerArray([Int])
    case rebeccaClass(RebeccaClass)

    init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let x = try? container.decode(RebeccaClass.self) {
            self = .rebeccaClass(x)
            return
        }
        if let x = try? container.decode([Int].self) {
            self = .integerArray(x)
            return
        }
        throw DecodingError.typeMismatch(Brookie.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Wrong type for Brookie"))
    }

    func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case .integerArray(let x):
            try container.encode(x)
        case .rebeccaClass(let x):
            try container.encode(x)
        }
    }
}

enum Bumboatman: Codable {
    case nullArray([JSONNull?])
    case string(String)
    case null

    init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let x = try? container.decode(String.self) {
            self = .string(x)
            return
        }
        if let x = try? container.decode([JSONNull?].self) {
            self = .nullArray(x)
            return
        }
        if container.decodeNil() {
            self = .null
            return
        }
        throw DecodingError.typeMismatch(Bumboatman.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Wrong type for Bumboatman"))
    }

    func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case .nullArray(let x):
            try container.encode(x)
        case .string(let x):
            try container.encode(x)
        case .null:
            try container.encodeNil()
        }
    }
}

enum Calaverite: Codable {
    case integerArray([Int])
    case string(String)

    init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let x = try? container.decode(String.self) {
            self = .string(x)
            return
        }
        if let x = try? container.decode([Int].self) {
            self = .integerArray(x)
            return
        }
        throw DecodingError.typeMismatch(Calaverite.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Wrong type for Calaverite"))
    }

    func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case .integerArray(let x):
            try container.encode(x)
        case .string(let x):
            try container.encode(x)
        }
    }
}

enum Catallactic: Codable {
    case bool(Bool)
    case integerMap([String: Int])
    case nullArray([JSONNull?])

    init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let x = try? container.decode(Bool.self) {
            self = .bool(x)
            return
        }
        if let x = try? container.decode([String: Int].self) {
            self = .integerMap(x)
            return
        }
        if let x = try? container.decode([JSONNull?].self) {
            self = .nullArray(x)
            return
        }
        throw DecodingError.typeMismatch(Catallactic.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Wrong type for Catallactic"))
    }

    func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case .bool(let x):
            try container.encode(x)
        case .integerMap(let x):
            try container.encode(x)
        case .nullArray(let x):
            try container.encode(x)
        }
    }
}

enum Cemental: Codable {
    case double(Double)
    case integerArray([Int])
    case integerMap([String: Int])

    init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let x = try? container.decode(Double.self) {
            self = .double(x)
            return
        }
        if let x = try? container.decode([String: Int].self) {
            self = .integerMap(x)
            return
        }
        if let x = try? container.decode([Int].self) {
            self = .integerArray(x)
            return
        }
        throw DecodingError.typeMismatch(Cemental.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Wrong type for Cemental"))
    }

    func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case .double(let x):
            try container.encode(x)
        case .integerArray(let x):
            try container.encode(x)
        case .integerMap(let x):
            try container.encode(x)
        }
    }
}

enum Cerograph: Codable {
    case nullMap([String: JSONNull?])
    case string(String)
    case null

    init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let x = try? container.decode(String.self) {
            self = .string(x)
            return
        }
        if let x = try? container.decode([String: JSONNull?].self) {
            self = .nullMap(x)
            return
        }
        if container.decodeNil() {
            self = .null
            return
        }
        throw DecodingError.typeMismatch(Cerograph.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Wrong type for Cerograph"))
    }

    func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case .nullMap(let x):
            try container.encode(x)
        case .string(let x):
            try container.encode(x)
        case .null:
            try container.encodeNil()
        }
    }
}

enum ChemotherapeuticUnion: Codable {
    case chemotherapeuticClass(ChemotherapeuticClass)
    case integer(Int)

    init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let x = try? container.decode(Int.self) {
            self = .integer(x)
            return
        }
        if let x = try? container.decode(ChemotherapeuticClass.self) {
            self = .chemotherapeuticClass(x)
            return
        }
        throw DecodingError.typeMismatch(ChemotherapeuticUnion.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Wrong type for ChemotherapeuticUnion"))
    }

    func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case .chemotherapeuticClass(let x):
            try container.encode(x)
        case .integer(let x):
            try container.encode(x)
        }
    }
}

class ChemotherapeuticClass: Codable {
    let angioneurotic, availment, bladelet: JSONNull?
    let catharticalness: Double?
    let caulis, chalcus: JSONNull?
    let chirotherium: Int?
    let disdiapason: String?
    let enteradenological: JSONNull?
    let homocerc: Bool?
    let imporosity, insistently, intraparietal, ivied: JSONNull?
    let maureen, nonbookish, nostochine, nutcracker: JSONNull?
    let ofttimes, phenocryst, precoincident, ramiferous: JSONNull?
    let stagmometer, tetherball, unshy: JSONNull?

    enum CodingKeys: String, CodingKey {
        case angioneurotic, availment, bladelet, catharticalness, caulis, chalcus
        case chirotherium = "Chirotherium"
        case disdiapason, enteradenological, homocerc, imporosity, insistently, intraparietal, ivied
        case maureen = "Maureen"
        case nonbookish, nostochine, nutcracker, ofttimes, phenocryst, precoincident, ramiferous, stagmometer, tetherball, unshy
    }

    init(angioneurotic: JSONNull?, availment: JSONNull?, bladelet: JSONNull?, catharticalness: Double?, caulis: JSONNull?, chalcus: JSONNull?, chirotherium: Int?, disdiapason: String?, enteradenological: JSONNull?, homocerc: Bool?, imporosity: JSONNull?, insistently: JSONNull?, intraparietal: JSONNull?, ivied: JSONNull?, maureen: JSONNull?, nonbookish: JSONNull?, nostochine: JSONNull?, nutcracker: JSONNull?, ofttimes: JSONNull?, phenocryst: JSONNull?, precoincident: JSONNull?, ramiferous: JSONNull?, stagmometer: JSONNull?, tetherball: JSONNull?, unshy: JSONNull?) {
        self.angioneurotic = angioneurotic
        self.availment = availment
        self.bladelet = bladelet
        self.catharticalness = catharticalness
        self.caulis = caulis
        self.chalcus = chalcus
        self.chirotherium = chirotherium
        self.disdiapason = disdiapason
        self.enteradenological = enteradenological
        self.homocerc = homocerc
        self.imporosity = imporosity
        self.insistently = insistently
        self.intraparietal = intraparietal
        self.ivied = ivied
        self.maureen = maureen
        self.nonbookish = nonbookish
        self.nostochine = nostochine
        self.nutcracker = nutcracker
        self.ofttimes = ofttimes
        self.phenocryst = phenocryst
        self.precoincident = precoincident
        self.ramiferous = ramiferous
        self.stagmometer = stagmometer
        self.tetherball = tetherball
        self.unshy = unshy
    }
}

enum Chytridiaceae: Codable {
    case bool(Bool)
    case nullMap([String: JSONNull?])
    case null

    init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let x = try? container.decode(Bool.self) {
            self = .bool(x)
            return
        }
        if let x = try? container.decode([String: JSONNull?].self) {
            self = .nullMap(x)
            return
        }
        if container.decodeNil() {
            self = .null
            return
        }
        throw DecodingError.typeMismatch(Chytridiaceae.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Wrong type for Chytridiaceae"))
    }

    func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case .bool(let x):
            try container.encode(x)
        case .nullMap(let x):
            try container.encode(x)
        case .null:
            try container.encodeNil()
        }
    }
}

enum Cimelia: Codable {
    case integerArray([Int])
    case rebeccaClass(RebeccaClass)
    case null

    init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let x = try? container.decode(RebeccaClass.self) {
            self = .rebeccaClass(x)
            return
        }
        if let x = try? container.decode([Int].self) {
            self = .integerArray(x)
            return
        }
        if container.decodeNil() {
            self = .null
            return
        }
        throw DecodingError.typeMismatch(Cimelia.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Wrong type for Cimelia"))
    }

    func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case .integerArray(let x):
            try container.encode(x)
        case .rebeccaClass(let x):
            try container.encode(x)
        case .null:
            try container.encodeNil()
        }
    }
}

enum CoadjustUnion: Codable {
    case coadjustClass(CoadjustClass)
    case double(Double)

    init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let x = try? container.decode(Double.self) {
            self = .double(x)
            return
        }
        if let x = try? container.decode(CoadjustClass.self) {
            self = .coadjustClass(x)
            return
        }
        throw DecodingError.typeMismatch(CoadjustUnion.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Wrong type for CoadjustUnion"))
    }

    func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case .coadjustClass(let x):
            try container.encode(x)
        case .double(let x):
            try container.encode(x)
        }
    }
}

class CoadjustClass: Codable {
    let amidosulphonal, benny: JSONNull?
    let catharticalness: Double?
    let chirotherium: Int?
    let disdiapason: String?
    let ensnare: JSONNull?
    let homocerc: Bool?
    let hybridizer, leastwise, lof, monkhood: JSONNull?
    let netherlandish, nonbookish, peonism, phonelescope: JSONNull?
    let porphyrogeniture, preindemnify, rosal, scalenous: JSONNull?
    let scopine, sedaceae, suberinize, symbiot: JSONNull?
    let tablefellow, unchargeable: JSONNull?

    enum CodingKeys: String, CodingKey {
        case amidosulphonal
        case benny = "Benny"
        case catharticalness
        case chirotherium = "Chirotherium"
        case disdiapason, ensnare, homocerc, hybridizer, leastwise, lof, monkhood
        case netherlandish = "Netherlandish"
        case nonbookish, peonism
        case phonelescope = "Phonelescope"
        case porphyrogeniture, preindemnify, rosal, scalenous, scopine
        case sedaceae = "Sedaceae"
        case suberinize, symbiot, tablefellow, unchargeable
    }

    init(amidosulphonal: JSONNull?, benny: JSONNull?, catharticalness: Double?, chirotherium: Int?, disdiapason: String?, ensnare: JSONNull?, homocerc: Bool?, hybridizer: JSONNull?, leastwise: JSONNull?, lof: JSONNull?, monkhood: JSONNull?, netherlandish: JSONNull?, nonbookish: JSONNull?, peonism: JSONNull?, phonelescope: JSONNull?, porphyrogeniture: JSONNull?, preindemnify: JSONNull?, rosal: JSONNull?, scalenous: JSONNull?, scopine: JSONNull?, sedaceae: JSONNull?, suberinize: JSONNull?, symbiot: JSONNull?, tablefellow: JSONNull?, unchargeable: JSONNull?) {
        self.amidosulphonal = amidosulphonal
        self.benny = benny
        self.catharticalness = catharticalness
        self.chirotherium = chirotherium
        self.disdiapason = disdiapason
        self.ensnare = ensnare
        self.homocerc = homocerc
        self.hybridizer = hybridizer
        self.leastwise = leastwise
        self.lof = lof
        self.monkhood = monkhood
        self.netherlandish = netherlandish
        self.nonbookish = nonbookish
        self.peonism = peonism
        self.phonelescope = phonelescope
        self.porphyrogeniture = porphyrogeniture
        self.preindemnify = preindemnify
        self.rosal = rosal
        self.scalenous = scalenous
        self.scopine = scopine
        self.sedaceae = sedaceae
        self.suberinize = suberinize
        self.symbiot = symbiot
        self.tablefellow = tablefellow
        self.unchargeable = unchargeable
    }
}

enum Consilience: Codable {
    case double(Double)
    case integerMap([String: Int])

    init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let x = try? container.decode(Double.self) {
            self = .double(x)
            return
        }
        if let x = try? container.decode([String: Int].self) {
            self = .integerMap(x)
            return
        }
        throw DecodingError.typeMismatch(Consilience.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Wrong type for Consilience"))
    }

    func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case .double(let x):
            try container.encode(x)
        case .integerMap(let x):
            try container.encode(x)
        }
    }
}

enum Constructor: Codable {
    case bool(Bool)
    case unionMap([String: Int?])

    init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let x = try? container.decode(Bool.self) {
            self = .bool(x)
            return
        }
        if let x = try? container.decode([String: Int?].self) {
            self = .unionMap(x)
            return
        }
        throw DecodingError.typeMismatch(Constructor.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Wrong type for Constructor"))
    }

    func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case .bool(let x):
            try container.encode(x)
        case .unionMap(let x):
            try container.encode(x)
        }
    }
}

enum Continuative: Codable {
    case integerMap([String: Int])
    case string(String)

    init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let x = try? container.decode(String.self) {
            self = .string(x)
            return
        }
        if let x = try? container.decode([String: Int].self) {
            self = .integerMap(x)
            return
        }
        throw DecodingError.typeMismatch(Continuative.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Wrong type for Continuative"))
    }

    func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case .integerMap(let x):
            try container.encode(x)
        case .string(let x):
            try container.encode(x)
        }
    }
}

enum Credulity: Codable {
    case integer(Int)
    case nullMap([String: JSONNull?])
    case string(String)

    init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let x = try? container.decode(Int.self) {
            self = .integer(x)
            return
        }
        if let x = try? container.decode(String.self) {
            self = .string(x)
            return
        }
        if let x = try? container.decode([String: JSONNull?].self) {
            self = .nullMap(x)
            return
        }
        throw DecodingError.typeMismatch(Credulity.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Wrong type for Credulity"))
    }

    func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case .integer(let x):
            try container.encode(x)
        case .nullMap(let x):
            try container.encode(x)
        case .string(let x):
            try container.encode(x)
        }
    }
}

enum Creviced: Codable {
    case bool(Bool)
    case integerMap([String: Int])
    case string(String)

    init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let x = try? container.decode(Bool.self) {
            self = .bool(x)
            return
        }
        if let x = try? container.decode(String.self) {
            self = .string(x)
            return
        }
        if let x = try? container.decode([String: Int].self) {
            self = .integerMap(x)
            return
        }
        throw DecodingError.typeMismatch(Creviced.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Wrong type for Creviced"))
    }

    func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case .bool(let x):
            try container.encode(x)
        case .integerMap(let x):
            try container.encode(x)
        case .string(let x):
            try container.encode(x)
        }
    }
}

enum Deruralize: Codable {
    case bool(Bool)
    case nullArray([JSONNull?])
    case nullMap([String: JSONNull?])

    init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let x = try? container.decode(Bool.self) {
            self = .bool(x)
            return
        }
        if let x = try? container.decode([String: JSONNull?].self) {
            self = .nullMap(x)
            return
        }
        if let x = try? container.decode([JSONNull?].self) {
            self = .nullArray(x)
            return
        }
        throw DecodingError.typeMismatch(Deruralize.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Wrong type for Deruralize"))
    }

    func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case .bool(let x):
            try container.encode(x)
        case .nullArray(let x):
            try container.encode(x)
        case .nullMap(let x):
            try container.encode(x)
        }
    }
}

enum Diaerese: Codable {
    case bool(Bool)
    case integerArray([Int])
    case nullMap([String: JSONNull?])

    init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let x = try? container.decode(Bool.self) {
            self = .bool(x)
            return
        }
        if let x = try? container.decode([String: JSONNull?].self) {
            self = .nullMap(x)
            return
        }
        if let x = try? container.decode([Int].self) {
            self = .integerArray(x)
            return
        }
        throw DecodingError.typeMismatch(Diaerese.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Wrong type for Diaerese"))
    }

    func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case .bool(let x):
            try container.encode(x)
        case .integerArray(let x):
            try container.encode(x)
        case .nullMap(let x):
            try container.encode(x)
        }
    }
}

enum DiscordiaUnion: Codable {
    case discordiaClass(DiscordiaClass)
    case integerArray([Int])

    init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let x = try? container.decode(DiscordiaClass.self) {
            self = .discordiaClass(x)
            return
        }
        if let x = try? container.decode([Int].self) {
            self = .integerArray(x)
            return
        }
        throw DecodingError.typeMismatch(DiscordiaUnion.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Wrong type for DiscordiaUnion"))
    }

    func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case .discordiaClass(let x):
            try container.encode(x)
        case .integerArray(let x):
            try container.encode(x)
        }
    }
}

class DiscordiaClass: Codable {
    let altaic, amoristic, blennophthalmia: Int?
    let catharticalness: Double?
    let chirotherium, disciplinability: Int?
    let disdiapason: String?
    let goofer: Int?
    let homocerc: Bool?
    let laryngograph, leucitis, lymphocyst, microcosmology: Int?
    let nauseation: Int?
    let nonbookish: JSONNull?
    let patarin, preliberal, prettifier, rangework: Int?
    let redient, subfusiform, suicidical, swow: Int?
    let wastrel, wingle: Int?

    enum CodingKeys: String, CodingKey {
        case altaic = "Altaic"
        case amoristic, blennophthalmia, catharticalness
        case chirotherium = "Chirotherium"
        case disciplinability, disdiapason, goofer, homocerc, laryngograph, leucitis, lymphocyst, microcosmology, nauseation, nonbookish
        case patarin = "Patarin"
        case preliberal, prettifier, rangework, redient, subfusiform, suicidical, swow, wastrel, wingle
    }

    init(altaic: Int?, amoristic: Int?, blennophthalmia: Int?, catharticalness: Double?, chirotherium: Int?, disciplinability: Int?, disdiapason: String?, goofer: Int?, homocerc: Bool?, laryngograph: Int?, leucitis: Int?, lymphocyst: Int?, microcosmology: Int?, nauseation: Int?, nonbookish: JSONNull?, patarin: Int?, preliberal: Int?, prettifier: Int?, rangework: Int?, redient: Int?, subfusiform: Int?, suicidical: Int?, swow: Int?, wastrel: Int?, wingle: Int?) {
        self.altaic = altaic
        self.amoristic = amoristic
        self.blennophthalmia = blennophthalmia
        self.catharticalness = catharticalness
        self.chirotherium = chirotherium
        self.disciplinability = disciplinability
        self.disdiapason = disdiapason
        self.goofer = goofer
        self.homocerc = homocerc
        self.laryngograph = laryngograph
        self.leucitis = leucitis
        self.lymphocyst = lymphocyst
        self.microcosmology = microcosmology
        self.nauseation = nauseation
        self.nonbookish = nonbookish
        self.patarin = patarin
        self.preliberal = preliberal
        self.prettifier = prettifier
        self.rangework = rangework
        self.redient = redient
        self.subfusiform = subfusiform
        self.suicidical = suicidical
        self.swow = swow
        self.wastrel = wastrel
        self.wingle = wingle
    }
}

enum Downstroke: Codable {
    case bool(Bool)
    case nullArray([JSONNull?])
    case string(String)

    init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let x = try? container.decode(Bool.self) {
            self = .bool(x)
            return
        }
        if let x = try? container.decode(String.self) {
            self = .string(x)
            return
        }
        if let x = try? container.decode([JSONNull?].self) {
            self = .nullArray(x)
            return
        }
        throw DecodingError.typeMismatch(Downstroke.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Wrong type for Downstroke"))
    }

    func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case .bool(let x):
            try container.encode(x)
        case .nullArray(let x):
            try container.encode(x)
        case .string(let x):
            try container.encode(x)
        }
    }
}

enum Eleutheromania: Codable {
    case double(Double)
    case integerMap([String: Int])
    case string(String)

    init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let x = try? container.decode(Double.self) {
            self = .double(x)
            return
        }
        if let x = try? container.decode(String.self) {
            self = .string(x)
            return
        }
        if let x = try? container.decode([String: Int].self) {
            self = .integerMap(x)
            return
        }
        throw DecodingError.typeMismatch(Eleutheromania.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Wrong type for Eleutheromania"))
    }

    func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case .double(let x):
            try container.encode(x)
        case .integerMap(let x):
            try container.encode(x)
        case .string(let x):
            try container.encode(x)
        }
    }
}

enum Endomyce: Codable {
    case integer(Int)
    case string(String)

    init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let x = try? container.decode(Int.self) {
            self = .integer(x)
            return
        }
        if let x = try? container.decode(String.self) {
            self = .string(x)
            return
        }
        throw DecodingError.typeMismatch(Endomyce.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Wrong type for Endomyce"))
    }

    func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case .integer(let x):
            try container.encode(x)
        case .string(let x):
            try container.encode(x)
        }
    }
}

enum Entomoid: Codable {
    case integer(Int)
    case rebeccaClass(RebeccaClass)

    init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let x = try? container.decode(Int.self) {
            self = .integer(x)
            return
        }
        if let x = try? container.decode(RebeccaClass.self) {
            self = .rebeccaClass(x)
            return
        }
        throw DecodingError.typeMismatch(Entomoid.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Wrong type for Entomoid"))
    }

    func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case .integer(let x):
            try container.encode(x)
        case .rebeccaClass(let x):
            try container.encode(x)
        }
    }
}

enum Epinephelidae: Codable {
    case bool(Bool)
    case integer(Int)
    case string(String)

    init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let x = try? container.decode(Bool.self) {
            self = .bool(x)
            return
        }
        if let x = try? container.decode(Int.self) {
            self = .integer(x)
            return
        }
        if let x = try? container.decode(String.self) {
            self = .string(x)
            return
        }
        throw DecodingError.typeMismatch(Epinephelidae.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Wrong type for Epinephelidae"))
    }

    func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case .bool(let x):
            try container.encode(x)
        case .integer(let x):
            try container.encode(x)
        case .string(let x):
            try container.encode(x)
        }
    }
}

enum Epipaleolithic: Codable {
    case double(Double)
    case integerArray([Int])

    init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let x = try? container.decode(Double.self) {
            self = .double(x)
            return
        }
        if let x = try? container.decode([Int].self) {
            self = .integerArray(x)
            return
        }
        throw DecodingError.typeMismatch(Epipaleolithic.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Wrong type for Epipaleolithic"))
    }

    func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case .double(let x):
            try container.encode(x)
        case .integerArray(let x):
            try container.encode(x)
        }
    }
}

enum Eupatorium: Codable {
    case integerMap([String: Int])
    case nullArray([JSONNull?])

    init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let x = try? container.decode([String: Int].self) {
            self = .integerMap(x)
            return
        }
        if let x = try? container.decode([JSONNull?].self) {
            self = .nullArray(x)
            return
        }
        throw DecodingError.typeMismatch(Eupatorium.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Wrong type for Eupatorium"))
    }

    func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case .integerMap(let x):
            try container.encode(x)
        case .nullArray(let x):
            try container.encode(x)
        }
    }
}

enum Expropriable: Codable {
    case double(Double)
    case nullArray([JSONNull?])
    case rebeccaClass(RebeccaClass)

    init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let x = try? container.decode(Double.self) {
            self = .double(x)
            return
        }
        if let x = try? container.decode(RebeccaClass.self) {
            self = .rebeccaClass(x)
            return
        }
        if let x = try? container.decode([JSONNull?].self) {
            self = .nullArray(x)
            return
        }
        throw DecodingError.typeMismatch(Expropriable.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Wrong type for Expropriable"))
    }

    func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case .double(let x):
            try container.encode(x)
        case .nullArray(let x):
            try container.encode(x)
        case .rebeccaClass(let x):
            try container.encode(x)
        }
    }
}

enum Faggingly: Codable {
    case double(Double)
    case nullMap([String: JSONNull?])

    init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let x = try? container.decode(Double.self) {
            self = .double(x)
            return
        }
        if let x = try? container.decode([String: JSONNull?].self) {
            self = .nullMap(x)
            return
        }
        throw DecodingError.typeMismatch(Faggingly.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Wrong type for Faggingly"))
    }

    func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case .double(let x):
            try container.encode(x)
        case .nullMap(let x):
            try container.encode(x)
        }
    }
}

enum Fenk: Codable {
    case nullMap([String: JSONNull?])
    case string(String)

    init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let x = try? container.decode(String.self) {
            self = .string(x)
            return
        }
        if let x = try? container.decode([String: JSONNull?].self) {
            self = .nullMap(x)
            return
        }
        throw DecodingError.typeMismatch(Fenk.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Wrong type for Fenk"))
    }

    func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case .nullMap(let x):
            try container.encode(x)
        case .string(let x):
            try container.encode(x)
        }
    }
}

enum Flagmaking: Codable {
    case bool(Bool)
    case double(Double)
    case nullMap([String: JSONNull?])

    init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let x = try? container.decode(Bool.self) {
            self = .bool(x)
            return
        }
        if let x = try? container.decode(Double.self) {
            self = .double(x)
            return
        }
        if let x = try? container.decode([String: JSONNull?].self) {
            self = .nullMap(x)
            return
        }
        throw DecodingError.typeMismatch(Flagmaking.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Wrong type for Flagmaking"))
    }

    func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case .bool(let x):
            try container.encode(x)
        case .double(let x):
            try container.encode(x)
        case .nullMap(let x):
            try container.encode(x)
        }
    }
}

enum Fluorometer: Codable {
    case integer(Int)
    case string(String)
    case null

    init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let x = try? container.decode(Int.self) {
            self = .integer(x)
            return
        }
        if let x = try? container.decode(String.self) {
            self = .string(x)
            return
        }
        if container.decodeNil() {
            self = .null
            return
        }
        throw DecodingError.typeMismatch(Fluorometer.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Wrong type for Fluorometer"))
    }

    func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case .integer(let x):
            try container.encode(x)
        case .string(let x):
            try container.encode(x)
        case .null:
            try container.encodeNil()
        }
    }
}

enum Fuzzy: Codable {
    case integer(Int)
    case unionMap([String: Int?])

    init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let x = try? container.decode(Int.self) {
            self = .integer(x)
            return
        }
        if let x = try? container.decode([String: Int?].self) {
            self = .unionMap(x)
            return
        }
        throw DecodingError.typeMismatch(Fuzzy.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Wrong type for Fuzzy"))
    }

    func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case .integer(let x):
            try container.encode(x)
        case .unionMap(let x):
            try container.encode(x)
        }
    }
}

enum Gardenward: Codable {
    case bool(Bool)
    case integerArray([Int])
    case string(String)

    init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let x = try? container.decode(Bool.self) {
            self = .bool(x)
            return
        }
        if let x = try? container.decode(String.self) {
            self = .string(x)
            return
        }
        if let x = try? container.decode([Int].self) {
            self = .integerArray(x)
            return
        }
        throw DecodingError.typeMismatch(Gardenward.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Wrong type for Gardenward"))
    }

    func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case .bool(let x):
            try container.encode(x)
        case .integerArray(let x):
            try container.encode(x)
        case .string(let x):
            try container.encode(x)
        }
    }
}

enum Generalissimo: Codable {
    case bool(Bool)
    case integerMap([String: Int])
    case null

    init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let x = try? container.decode(Bool.self) {
            self = .bool(x)
            return
        }
        if let x = try? container.decode([String: Int].self) {
            self = .integerMap(x)
            return
        }
        if container.decodeNil() {
            self = .null
            return
        }
        throw DecodingError.typeMismatch(Generalissimo.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Wrong type for Generalissimo"))
    }

    func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case .bool(let x):
            try container.encode(x)
        case .integerMap(let x):
            try container.encode(x)
        case .null:
            try container.encodeNil()
        }
    }
}

enum Gryphosaurus: Codable {
    case integerArray([Int])
    case nullMap([String: JSONNull?])
    case string(String)

    init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let x = try? container.decode(String.self) {
            self = .string(x)
            return
        }
        if let x = try? container.decode([String: JSONNull?].self) {
            self = .nullMap(x)
            return
        }
        if let x = try? container.decode([Int].self) {
            self = .integerArray(x)
            return
        }
        throw DecodingError.typeMismatch(Gryphosaurus.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Wrong type for Gryphosaurus"))
    }

    func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case .integerArray(let x):
            try container.encode(x)
        case .nullMap(let x):
            try container.encode(x)
        case .string(let x):
            try container.encode(x)
        }
    }
}

enum Hemicrystalline: Codable {
    case rebeccaClass(RebeccaClass)
    case string(String)

    init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let x = try? container.decode(String.self) {
            self = .string(x)
            return
        }
        if let x = try? container.decode(RebeccaClass.self) {
            self = .rebeccaClass(x)
            return
        }
        throw DecodingError.typeMismatch(Hemicrystalline.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Wrong type for Hemicrystalline"))
    }

    func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case .rebeccaClass(let x):
            try container.encode(x)
        case .string(let x):
            try container.encode(x)
        }
    }
}

enum HemocoeleUnion: Codable {
    case hemocoeleClass(HemocoeleClass)
    case integerArray([Int])

    init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let x = try? container.decode(HemocoeleClass.self) {
            self = .hemocoeleClass(x)
            return
        }
        if let x = try? container.decode([Int].self) {
            self = .integerArray(x)
            return
        }
        throw DecodingError.typeMismatch(HemocoeleUnion.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Wrong type for HemocoeleUnion"))
    }

    func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case .hemocoeleClass(let x):
            try container.encode(x)
        case .integerArray(let x):
            try container.encode(x)
        }
    }
}

class HemocoeleClass: Codable {
    let acrogamy, amelification, autobiographic, berat: JSONNull?
    let catharticalness: Double?
    let chirotherium: Int?
    let disdiapason: String?
    let disproportionably, erythrite, graphic, hepatological: JSONNull?
    let homocerc: Bool?
    let incommensurably, misaffirm, nonbookish, pocketbook: JSONNull?
    let sclerometric, stambouline, stickpin, tubulure: JSONNull?
    let undelated, unsalt, untutelar, vagrant: JSONNull?
    let walt: JSONNull?

    enum CodingKeys: String, CodingKey {
        case acrogamy, amelification, autobiographic, berat, catharticalness
        case chirotherium = "Chirotherium"
        case disdiapason, disproportionably, erythrite, graphic, hepatological, homocerc, incommensurably, misaffirm, nonbookish, pocketbook, sclerometric, stambouline, stickpin, tubulure, undelated, unsalt, untutelar, vagrant
        case walt = "Walt"
    }

    init(acrogamy: JSONNull?, amelification: JSONNull?, autobiographic: JSONNull?, berat: JSONNull?, catharticalness: Double?, chirotherium: Int?, disdiapason: String?, disproportionably: JSONNull?, erythrite: JSONNull?, graphic: JSONNull?, hepatological: JSONNull?, homocerc: Bool?, incommensurably: JSONNull?, misaffirm: JSONNull?, nonbookish: JSONNull?, pocketbook: JSONNull?, sclerometric: JSONNull?, stambouline: JSONNull?, stickpin: JSONNull?, tubulure: JSONNull?, undelated: JSONNull?, unsalt: JSONNull?, untutelar: JSONNull?, vagrant: JSONNull?, walt: JSONNull?) {
        self.acrogamy = acrogamy
        self.amelification = amelification
        self.autobiographic = autobiographic
        self.berat = berat
        self.catharticalness = catharticalness
        self.chirotherium = chirotherium
        self.disdiapason = disdiapason
        self.disproportionably = disproportionably
        self.erythrite = erythrite
        self.graphic = graphic
        self.hepatological = hepatological
        self.homocerc = homocerc
        self.incommensurably = incommensurably
        self.misaffirm = misaffirm
        self.nonbookish = nonbookish
        self.pocketbook = pocketbook
        self.sclerometric = sclerometric
        self.stambouline = stambouline
        self.stickpin = stickpin
        self.tubulure = tubulure
        self.undelated = undelated
        self.unsalt = unsalt
        self.untutelar = untutelar
        self.vagrant = vagrant
        self.walt = walt
    }
}

enum Hoister: Codable {
    case rebeccaClass(RebeccaClass)
    case string(String)
    case null

    init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let x = try? container.decode(String.self) {
            self = .string(x)
            return
        }
        if let x = try? container.decode(RebeccaClass.self) {
            self = .rebeccaClass(x)
            return
        }
        if container.decodeNil() {
            self = .null
            return
        }
        throw DecodingError.typeMismatch(Hoister.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Wrong type for Hoister"))
    }

    func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case .rebeccaClass(let x):
            try container.encode(x)
        case .string(let x):
            try container.encode(x)
        case .null:
            try container.encodeNil()
        }
    }
}

enum Hyperpiesi: Codable {
    case nullArray([JSONNull?])
    case rebeccaClass(RebeccaClass)
    case null

    init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let x = try? container.decode(RebeccaClass.self) {
            self = .rebeccaClass(x)
            return
        }
        if let x = try? container.decode([JSONNull?].self) {
            self = .nullArray(x)
            return
        }
        if container.decodeNil() {
            self = .null
            return
        }
        throw DecodingError.typeMismatch(Hyperpiesi.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Wrong type for Hyperpiesi"))
    }

    func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case .nullArray(let x):
            try container.encode(x)
        case .rebeccaClass(let x):
            try container.encode(x)
        case .null:
            try container.encodeNil()
        }
    }
}

enum Hyppish: Codable {
    case bool(Bool)
    case string(String)
    case null

    init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let x = try? container.decode(Bool.self) {
            self = .bool(x)
            return
        }
        if let x = try? container.decode(String.self) {
            self = .string(x)
            return
        }
        if container.decodeNil() {
            self = .null
            return
        }
        throw DecodingError.typeMismatch(Hyppish.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Wrong type for Hyppish"))
    }

    func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case .bool(let x):
            try container.encode(x)
        case .string(let x):
            try container.encode(x)
        case .null:
            try container.encodeNil()
        }
    }
}

enum Idealizer: Codable {
    case integer(Int)
    case nullArray([JSONNull?])
    case rebeccaClass(RebeccaClass)

    init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let x = try? container.decode(Int.self) {
            self = .integer(x)
            return
        }
        if let x = try? container.decode(RebeccaClass.self) {
            self = .rebeccaClass(x)
            return
        }
        if let x = try? container.decode([JSONNull?].self) {
            self = .nullArray(x)
            return
        }
        throw DecodingError.typeMismatch(Idealizer.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Wrong type for Idealizer"))
    }

    func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case .integer(let x):
            try container.encode(x)
        case .nullArray(let x):
            try container.encode(x)
        case .rebeccaClass(let x):
            try container.encode(x)
        }
    }
}

enum Incrustator: Codable {
    case integer(Int)
    case integerArray([Int])
    case string(String)

    init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let x = try? container.decode(Int.self) {
            self = .integer(x)
            return
        }
        if let x = try? container.decode(String.self) {
            self = .string(x)
            return
        }
        if let x = try? container.decode([Int].self) {
            self = .integerArray(x)
            return
        }
        throw DecodingError.typeMismatch(Incrustator.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Wrong type for Incrustator"))
    }

    func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case .integer(let x):
            try container.encode(x)
        case .integerArray(let x):
            try container.encode(x)
        case .string(let x):
            try container.encode(x)
        }
    }
}

enum Intentiveness: Codable {
    case double(Double)
    case rebeccaClass(RebeccaClass)
    case string(String)

    init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let x = try? container.decode(Double.self) {
            self = .double(x)
            return
        }
        if let x = try? container.decode(String.self) {
            self = .string(x)
            return
        }
        if let x = try? container.decode(RebeccaClass.self) {
            self = .rebeccaClass(x)
            return
        }
        throw DecodingError.typeMismatch(Intentiveness.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Wrong type for Intentiveness"))
    }

    func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case .double(let x):
            try container.encode(x)
        case .rebeccaClass(let x):
            try container.encode(x)
        case .string(let x):
            try container.encode(x)
        }
    }
}

class Interacinar: Codable {
    let assapan: Double
    let benefactorship: Bool
    let triseriatim: String
    let tubbing: Int
    let untrimmed: JSONNull?

    init(assapan: Double, benefactorship: Bool, triseriatim: String, tubbing: Int, untrimmed: JSONNull?) {
        self.assapan = assapan
        self.benefactorship = benefactorship
        self.triseriatim = triseriatim
        self.tubbing = tubbing
        self.untrimmed = untrimmed
    }
}

enum Jacutinga: Codable {
    case integerArray([Int])
    case unionMap([String: Int?])

    init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let x = try? container.decode([String: Int?].self) {
            self = .unionMap(x)
            return
        }
        if let x = try? container.decode([Int].self) {
            self = .integerArray(x)
            return
        }
        throw DecodingError.typeMismatch(Jacutinga.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Wrong type for Jacutinga"))
    }

    func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case .integerArray(let x):
            try container.encode(x)
        case .unionMap(let x):
            try container.encode(x)
        }
    }
}

enum Juror: Codable {
    case bool(Bool)
    case nullMap([String: JSONNull?])

    init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let x = try? container.decode(Bool.self) {
            self = .bool(x)
            return
        }
        if let x = try? container.decode([String: JSONNull?].self) {
            self = .nullMap(x)
            return
        }
        throw DecodingError.typeMismatch(Juror.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Wrong type for Juror"))
    }

    func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case .bool(let x):
            try container.encode(x)
        case .nullMap(let x):
            try container.encode(x)
        }
    }
}

enum Kongoni: Codable {
    case integerArray([Int])
    case integerMap([String: Int])

    init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let x = try? container.decode([String: Int].self) {
            self = .integerMap(x)
            return
        }
        if let x = try? container.decode([Int].self) {
            self = .integerArray(x)
            return
        }
        throw DecodingError.typeMismatch(Kongoni.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Wrong type for Kongoni"))
    }

    func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case .integerArray(let x):
            try container.encode(x)
        case .integerMap(let x):
            try container.encode(x)
        }
    }
}

enum Koryak: Codable {
    case string(String)
    case unionMap([String: Int?])

    init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let x = try? container.decode(String.self) {
            self = .string(x)
            return
        }
        if let x = try? container.decode([String: Int?].self) {
            self = .unionMap(x)
            return
        }
        throw DecodingError.typeMismatch(Koryak.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Wrong type for Koryak"))
    }

    func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case .string(let x):
            try container.encode(x)
        case .unionMap(let x):
            try container.encode(x)
        }
    }
}

enum Ladronism: Codable {
    case double(Double)
    case nullMap([String: JSONNull?])
    case string(String)

    init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let x = try? container.decode(Double.self) {
            self = .double(x)
            return
        }
        if let x = try? container.decode(String.self) {
            self = .string(x)
            return
        }
        if let x = try? container.decode([String: JSONNull?].self) {
            self = .nullMap(x)
            return
        }
        throw DecodingError.typeMismatch(Ladronism.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Wrong type for Ladronism"))
    }

    func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case .double(let x):
            try container.encode(x)
        case .nullMap(let x):
            try container.encode(x)
        case .string(let x):
            try container.encode(x)
        }
    }
}

enum Landlubberly: Codable {
    case bool(Bool)
    case integer(Int)
    case nullMap([String: JSONNull?])

    init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let x = try? container.decode(Bool.self) {
            self = .bool(x)
            return
        }
        if let x = try? container.decode(Int.self) {
            self = .integer(x)
            return
        }
        if let x = try? container.decode([String: JSONNull?].self) {
            self = .nullMap(x)
            return
        }
        throw DecodingError.typeMismatch(Landlubberly.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Wrong type for Landlubberly"))
    }

    func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case .bool(let x):
            try container.encode(x)
        case .integer(let x):
            try container.encode(x)
        case .nullMap(let x):
            try container.encode(x)
        }
    }
}

enum LaviniaUnion: Codable {
    case laviniaClass(LaviniaClass)
    case string(String)

    init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let x = try? container.decode(String.self) {
            self = .string(x)
            return
        }
        if let x = try? container.decode(LaviniaClass.self) {
            self = .laviniaClass(x)
            return
        }
        throw DecodingError.typeMismatch(LaviniaUnion.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Wrong type for LaviniaUnion"))
    }

    func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case .laviniaClass(let x):
            try container.encode(x)
        case .string(let x):
            try container.encode(x)
        }
    }
}

class LaviniaClass: Codable {
    let agitable, asininity, benefiter, bronzelike: Int?
    let catharticalness: Double?
    let chirotherium, cholesteatomatous, deprivement: Int?
    let disdiapason: String?
    let flippantness, fogproof: Int?
    let homocerc: Bool?
    let merrymeeting: Int?
    let nonbookish: JSONNull?
    let overcareful, panaris, preacceptance, quinoxaline: Int?
    let sig, superconfusion, tacana, tillotter: Int?
    let tranquillize, unquestionable, uproute: Int?

    enum CodingKeys: String, CodingKey {
        case agitable, asininity, benefiter, bronzelike, catharticalness
        case chirotherium = "Chirotherium"
        case cholesteatomatous, deprivement, disdiapason, flippantness, fogproof, homocerc, merrymeeting, nonbookish, overcareful, panaris, preacceptance, quinoxaline, sig, superconfusion
        case tacana = "Tacana"
        case tillotter, tranquillize, unquestionable, uproute
    }

    init(agitable: Int?, asininity: Int?, benefiter: Int?, bronzelike: Int?, catharticalness: Double?, chirotherium: Int?, cholesteatomatous: Int?, deprivement: Int?, disdiapason: String?, flippantness: Int?, fogproof: Int?, homocerc: Bool?, merrymeeting: Int?, nonbookish: JSONNull?, overcareful: Int?, panaris: Int?, preacceptance: Int?, quinoxaline: Int?, sig: Int?, superconfusion: Int?, tacana: Int?, tillotter: Int?, tranquillize: Int?, unquestionable: Int?, uproute: Int?) {
        self.agitable = agitable
        self.asininity = asininity
        self.benefiter = benefiter
        self.bronzelike = bronzelike
        self.catharticalness = catharticalness
        self.chirotherium = chirotherium
        self.cholesteatomatous = cholesteatomatous
        self.deprivement = deprivement
        self.disdiapason = disdiapason
        self.flippantness = flippantness
        self.fogproof = fogproof
        self.homocerc = homocerc
        self.merrymeeting = merrymeeting
        self.nonbookish = nonbookish
        self.overcareful = overcareful
        self.panaris = panaris
        self.preacceptance = preacceptance
        self.quinoxaline = quinoxaline
        self.sig = sig
        self.superconfusion = superconfusion
        self.tacana = tacana
        self.tillotter = tillotter
        self.tranquillize = tranquillize
        self.unquestionable = unquestionable
        self.uproute = uproute
    }
}

enum Listener: Codable {
    case integer(Int)
    case nullArray([JSONNull?])

    init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let x = try? container.decode(Int.self) {
            self = .integer(x)
            return
        }
        if let x = try? container.decode([JSONNull?].self) {
            self = .nullArray(x)
            return
        }
        throw DecodingError.typeMismatch(Listener.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Wrong type for Listener"))
    }

    func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case .integer(let x):
            try container.encode(x)
        case .nullArray(let x):
            try container.encode(x)
        }
    }
}

enum LupusUnion: Codable {
    case integer(Int)
    case lupusClass(LupusClass)

    init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let x = try? container.decode(Int.self) {
            self = .integer(x)
            return
        }
        if let x = try? container.decode(LupusClass.self) {
            self = .lupusClass(x)
            return
        }
        throw DecodingError.typeMismatch(LupusUnion.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Wrong type for LupusUnion"))
    }

    func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case .integer(let x):
            try container.encode(x)
        case .lupusClass(let x):
            try container.encode(x)
        }
    }
}

class LupusClass: Codable {
    let catharticalness: Double?
    let chirotherium, chlorioninae, corvinae, crassina: Int?
    let disdiapason: String?
    let exiguity, farcist, holographical: Int?
    let homocerc: Bool?
    let ichthyophagan, implacable: Int?
    let nonbookish: JSONNull?
    let outshiner, overweather, protonegroid, shallowish: Int?
    let snoke, snout, surveillance, threshingtime: Int?
    let thysanocarpus, unsignificantly, unsnap, vendible: Int?

    enum CodingKeys: String, CodingKey {
        case catharticalness
        case chirotherium = "Chirotherium"
        case chlorioninae = "Chlorioninae"
        case corvinae = "Corvinae"
        case crassina = "Crassina"
        case disdiapason, exiguity, farcist, holographical, homocerc, ichthyophagan, implacable, nonbookish, outshiner, overweather, protonegroid, shallowish, snoke, snout, surveillance, threshingtime
        case thysanocarpus = "Thysanocarpus"
        case unsignificantly, unsnap, vendible
    }

    init(catharticalness: Double?, chirotherium: Int?, chlorioninae: Int?, corvinae: Int?, crassina: Int?, disdiapason: String?, exiguity: Int?, farcist: Int?, holographical: Int?, homocerc: Bool?, ichthyophagan: Int?, implacable: Int?, nonbookish: JSONNull?, outshiner: Int?, overweather: Int?, protonegroid: Int?, shallowish: Int?, snoke: Int?, snout: Int?, surveillance: Int?, threshingtime: Int?, thysanocarpus: Int?, unsignificantly: Int?, unsnap: Int?, vendible: Int?) {
        self.catharticalness = catharticalness
        self.chirotherium = chirotherium
        self.chlorioninae = chlorioninae
        self.corvinae = corvinae
        self.crassina = crassina
        self.disdiapason = disdiapason
        self.exiguity = exiguity
        self.farcist = farcist
        self.holographical = holographical
        self.homocerc = homocerc
        self.ichthyophagan = ichthyophagan
        self.implacable = implacable
        self.nonbookish = nonbookish
        self.outshiner = outshiner
        self.overweather = overweather
        self.protonegroid = protonegroid
        self.shallowish = shallowish
        self.snoke = snoke
        self.snout = snout
        self.surveillance = surveillance
        self.threshingtime = threshingtime
        self.thysanocarpus = thysanocarpus
        self.unsignificantly = unsignificantly
        self.unsnap = unsnap
        self.vendible = vendible
    }
}

class Maslin: Codable {
    let alicant: Int?
    let antiatonement: JSONNull?
    let anticorrosive: Int?
    let aphidozer, bakuninist: JSONNull?
    let be: Int?
    let catharticalness: Double?
    let chirotherium, chub, cuprosilicon, curtailedly: Int?
    let dellenite, dimitry: Int?
    let disdiapason: String?
    let edifying: JSONNull?
    let ethmoiditis: Int?
    let gastralgy: JSONNull?
    let goatherd, hammerdress: Int?
    let hangfire: JSONNull?
    let homocerc: Bool?
    let lacunosity: Int?
    let longiloquence: JSONNull?
    let mameliere: Int?
    let motherless, nonbookish, noncorrodible, nonsensicality: JSONNull?
    let oafishly: Int?
    let pfund, preadvisory, retroflexed: JSONNull?
    let saccharulmic, scowlful: Int?
    let secluded, slackage: JSONNull?
    let sphaeridial: Int?
    let spondulics: JSONNull?
    let subsecive: Int?
    let swellmobsman: JSONNull?
    let trachyglossate: Int?
    let trialogue: JSONNull?
    let unassuaged: Int?
    let ungross, unjudiciously: JSONNull?

    enum CodingKeys: String, CodingKey {
        case alicant = "Alicant"
        case antiatonement, anticorrosive, aphidozer
        case bakuninist = "Bakuninist"
        case be, catharticalness
        case chirotherium = "Chirotherium"
        case chub, cuprosilicon, curtailedly, dellenite
        case dimitry = "Dimitry"
        case disdiapason, edifying, ethmoiditis, gastralgy, goatherd, hammerdress, hangfire, homocerc, lacunosity, longiloquence, mameliere, motherless, nonbookish, noncorrodible, nonsensicality, oafishly, pfund, preadvisory, retroflexed, saccharulmic, scowlful, secluded, slackage, sphaeridial, spondulics, subsecive, swellmobsman, trachyglossate, trialogue, unassuaged, ungross, unjudiciously
    }

    init(alicant: Int?, antiatonement: JSONNull?, anticorrosive: Int?, aphidozer: JSONNull?, bakuninist: JSONNull?, be: Int?, catharticalness: Double?, chirotherium: Int?, chub: Int?, cuprosilicon: Int?, curtailedly: Int?, dellenite: Int?, dimitry: Int?, disdiapason: String?, edifying: JSONNull?, ethmoiditis: Int?, gastralgy: JSONNull?, goatherd: Int?, hammerdress: Int?, hangfire: JSONNull?, homocerc: Bool?, lacunosity: Int?, longiloquence: JSONNull?, mameliere: Int?, motherless: JSONNull?, nonbookish: JSONNull?, noncorrodible: JSONNull?, nonsensicality: JSONNull?, oafishly: Int?, pfund: JSONNull?, preadvisory: JSONNull?, retroflexed: JSONNull?, saccharulmic: Int?, scowlful: Int?, secluded: JSONNull?, slackage: JSONNull?, sphaeridial: Int?, spondulics: JSONNull?, subsecive: Int?, swellmobsman: JSONNull?, trachyglossate: Int?, trialogue: JSONNull?, unassuaged: Int?, ungross: JSONNull?, unjudiciously: JSONNull?) {
        self.alicant = alicant
        self.antiatonement = antiatonement
        self.anticorrosive = anticorrosive
        self.aphidozer = aphidozer
        self.bakuninist = bakuninist
        self.be = be
        self.catharticalness = catharticalness
        self.chirotherium = chirotherium
        self.chub = chub
        self.cuprosilicon = cuprosilicon
        self.curtailedly = curtailedly
        self.dellenite = dellenite
        self.dimitry = dimitry
        self.disdiapason = disdiapason
        self.edifying = edifying
        self.ethmoiditis = ethmoiditis
        self.gastralgy = gastralgy
        self.goatherd = goatherd
        self.hammerdress = hammerdress
        self.hangfire = hangfire
        self.homocerc = homocerc
        self.lacunosity = lacunosity
        self.longiloquence = longiloquence
        self.mameliere = mameliere
        self.motherless = motherless
        self.nonbookish = nonbookish
        self.noncorrodible = noncorrodible
        self.nonsensicality = nonsensicality
        self.oafishly = oafishly
        self.pfund = pfund
        self.preadvisory = preadvisory
        self.retroflexed = retroflexed
        self.saccharulmic = saccharulmic
        self.scowlful = scowlful
        self.secluded = secluded
        self.slackage = slackage
        self.sphaeridial = sphaeridial
        self.spondulics = spondulics
        self.subsecive = subsecive
        self.swellmobsman = swellmobsman
        self.trachyglossate = trachyglossate
        self.trialogue = trialogue
        self.unassuaged = unassuaged
        self.ungross = ungross
        self.unjudiciously = unjudiciously
    }
}

enum Monazite: Codable {
    case double(Double)
    case rebeccaClass(RebeccaClass)

    init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let x = try? container.decode(Double.self) {
            self = .double(x)
            return
        }
        if let x = try? container.decode(RebeccaClass.self) {
            self = .rebeccaClass(x)
            return
        }
        throw DecodingError.typeMismatch(Monazite.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Wrong type for Monazite"))
    }

    func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case .double(let x):
            try container.encode(x)
        case .rebeccaClass(let x):
            try container.encode(x)
        }
    }
}

enum Monoliteral: Codable {
    case bool(Bool)
    case nullArray([JSONNull?])

    init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let x = try? container.decode(Bool.self) {
            self = .bool(x)
            return
        }
        if let x = try? container.decode([JSONNull?].self) {
            self = .nullArray(x)
            return
        }
        throw DecodingError.typeMismatch(Monoliteral.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Wrong type for Monoliteral"))
    }

    func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case .bool(let x):
            try container.encode(x)
        case .nullArray(let x):
            try container.encode(x)
        }
    }
}

enum MonotheisticallyUnion: Codable {
    case monotheisticallyClass(MonotheisticallyClass)
    case nullArray([JSONNull?])

    init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let x = try? container.decode(MonotheisticallyClass.self) {
            self = .monotheisticallyClass(x)
            return
        }
        if let x = try? container.decode([JSONNull?].self) {
            self = .nullArray(x)
            return
        }
        throw DecodingError.typeMismatch(MonotheisticallyUnion.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Wrong type for MonotheisticallyUnion"))
    }

    func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case .monotheisticallyClass(let x):
            try container.encode(x)
        case .nullArray(let x):
            try container.encode(x)
        }
    }
}

class MonotheisticallyClass: Codable {
    let blaspheme: JSONNull?
    let catharticalness: Double?
    let celiosalpingectomy: JSONNull?
    let chirotherium: Int?
    let consummativeness: JSONNull?
    let disdiapason: String?
    let egestive, enchylema, gasconade, holidayer: JSONNull?
    let homocerc: Bool?
    let intuitionalism, lophiostomate, nonbookish, nonvolition: JSONNull?
    let palatableness, pimpery, previolation, reconveyance: JSONNull?
    let registership, rhyacolite, smithereens, superedification: JSONNull?
    let trust, whitestone: JSONNull?

    enum CodingKeys: String, CodingKey {
        case blaspheme, catharticalness, celiosalpingectomy
        case chirotherium = "Chirotherium"
        case consummativeness, disdiapason, egestive, enchylema, gasconade, holidayer, homocerc, intuitionalism, lophiostomate, nonbookish, nonvolition, palatableness, pimpery, previolation, reconveyance, registership, rhyacolite, smithereens, superedification, trust, whitestone
    }

    init(blaspheme: JSONNull?, catharticalness: Double?, celiosalpingectomy: JSONNull?, chirotherium: Int?, consummativeness: JSONNull?, disdiapason: String?, egestive: JSONNull?, enchylema: JSONNull?, gasconade: JSONNull?, holidayer: JSONNull?, homocerc: Bool?, intuitionalism: JSONNull?, lophiostomate: JSONNull?, nonbookish: JSONNull?, nonvolition: JSONNull?, palatableness: JSONNull?, pimpery: JSONNull?, previolation: JSONNull?, reconveyance: JSONNull?, registership: JSONNull?, rhyacolite: JSONNull?, smithereens: JSONNull?, superedification: JSONNull?, trust: JSONNull?, whitestone: JSONNull?) {
        self.blaspheme = blaspheme
        self.catharticalness = catharticalness
        self.celiosalpingectomy = celiosalpingectomy
        self.chirotherium = chirotherium
        self.consummativeness = consummativeness
        self.disdiapason = disdiapason
        self.egestive = egestive
        self.enchylema = enchylema
        self.gasconade = gasconade
        self.holidayer = holidayer
        self.homocerc = homocerc
        self.intuitionalism = intuitionalism
        self.lophiostomate = lophiostomate
        self.nonbookish = nonbookish
        self.nonvolition = nonvolition
        self.palatableness = palatableness
        self.pimpery = pimpery
        self.previolation = previolation
        self.reconveyance = reconveyance
        self.registership = registership
        self.rhyacolite = rhyacolite
        self.smithereens = smithereens
        self.superedification = superedification
        self.trust = trust
        self.whitestone = whitestone
    }
}

enum Montage: Codable {
    case double(Double)
    case nullArray([JSONNull?])
    case string(String)

    init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let x = try? container.decode(Double.self) {
            self = .double(x)
            return
        }
        if let x = try? container.decode(String.self) {
            self = .string(x)
            return
        }
        if let x = try? container.decode([JSONNull?].self) {
            self = .nullArray(x)
            return
        }
        throw DecodingError.typeMismatch(Montage.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Wrong type for Montage"))
    }

    func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case .double(let x):
            try container.encode(x)
        case .nullArray(let x):
            try container.encode(x)
        case .string(let x):
            try container.encode(x)
        }
    }
}

enum Moralness: Codable {
    case double(Double)
    case nullArray([JSONNull?])
    case null

    init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let x = try? container.decode(Double.self) {
            self = .double(x)
            return
        }
        if let x = try? container.decode([JSONNull?].self) {
            self = .nullArray(x)
            return
        }
        if container.decodeNil() {
            self = .null
            return
        }
        throw DecodingError.typeMismatch(Moralness.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Wrong type for Moralness"))
    }

    func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case .double(let x):
            try container.encode(x)
        case .nullArray(let x):
            try container.encode(x)
        case .null:
            try container.encodeNil()
        }
    }
}

enum Mulishly: Codable {
    case double(Double)
    case integerArray([Int])
    case null

    init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let x = try? container.decode(Double.self) {
            self = .double(x)
            return
        }
        if let x = try? container.decode([Int].self) {
            self = .integerArray(x)
            return
        }
        if container.decodeNil() {
            self = .null
            return
        }
        throw DecodingError.typeMismatch(Mulishly.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Wrong type for Mulishly"))
    }

    func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case .double(let x):
            try container.encode(x)
        case .integerArray(let x):
            try container.encode(x)
        case .null:
            try container.encodeNil()
        }
    }
}

enum Myoscope: Codable {
    case bool(Bool)
    case integer(Int)
    case nullArray([JSONNull?])

    init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let x = try? container.decode(Bool.self) {
            self = .bool(x)
            return
        }
        if let x = try? container.decode(Int.self) {
            self = .integer(x)
            return
        }
        if let x = try? container.decode([JSONNull?].self) {
            self = .nullArray(x)
            return
        }
        throw DecodingError.typeMismatch(Myoscope.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Wrong type for Myoscope"))
    }

    func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case .bool(let x):
            try container.encode(x)
        case .integer(let x):
            try container.encode(x)
        case .nullArray(let x):
            try container.encode(x)
        }
    }
}

enum Neuromastic: Codable {
    case double(Double)
    case nullArray([JSONNull?])

    init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let x = try? container.decode(Double.self) {
            self = .double(x)
            return
        }
        if let x = try? container.decode([JSONNull?].self) {
            self = .nullArray(x)
            return
        }
        throw DecodingError.typeMismatch(Neuromastic.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Wrong type for Neuromastic"))
    }

    func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case .double(let x):
            try container.encode(x)
        case .nullArray(let x):
            try container.encode(x)
        }
    }
}

class Noncontributing: Codable {
    let estevin: String
    let jolterhead: Double
    let sauternes: Int
    let sparsely: Bool
    let unrequested: JSONNull?

    init(estevin: String, jolterhead: Double, sauternes: Int, sparsely: Bool, unrequested: JSONNull?) {
        self.estevin = estevin
        self.jolterhead = jolterhead
        self.sauternes = sauternes
        self.sparsely = sparsely
        self.unrequested = unrequested
    }
}

enum Nonnervous: Codable {
    case bool(Bool)
    case integer(Int)

    init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let x = try? container.decode(Bool.self) {
            self = .bool(x)
            return
        }
        if let x = try? container.decode(Int.self) {
            self = .integer(x)
            return
        }
        throw DecodingError.typeMismatch(Nonnervous.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Wrong type for Nonnervous"))
    }

    func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case .bool(let x):
            try container.encode(x)
        case .integer(let x):
            try container.encode(x)
        }
    }
}

enum Nonvaluation: Codable {
    case bool(Bool)
    case double(Double)
    case nullArray([JSONNull?])

    init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let x = try? container.decode(Bool.self) {
            self = .bool(x)
            return
        }
        if let x = try? container.decode(Double.self) {
            self = .double(x)
            return
        }
        if let x = try? container.decode([JSONNull?].self) {
            self = .nullArray(x)
            return
        }
        throw DecodingError.typeMismatch(Nonvaluation.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Wrong type for Nonvaluation"))
    }

    func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case .bool(let x):
            try container.encode(x)
        case .double(let x):
            try container.encode(x)
        case .nullArray(let x):
            try container.encode(x)
        }
    }
}

enum Occupationalist: Codable {
    case nullArray([JSONNull?])
    case nullMap([String: JSONNull?])
    case null

    init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let x = try? container.decode([String: JSONNull?].self) {
            self = .nullMap(x)
            return
        }
        if let x = try? container.decode([JSONNull?].self) {
            self = .nullArray(x)
            return
        }
        if container.decodeNil() {
            self = .null
            return
        }
        throw DecodingError.typeMismatch(Occupationalist.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Wrong type for Occupationalist"))
    }

    func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case .nullArray(let x):
            try container.encode(x)
        case .nullMap(let x):
            try container.encode(x)
        case .null:
            try container.encodeNil()
        }
    }
}

enum Oskar: Codable {
    case integerArray([Int])
    case nullMap([String: JSONNull?])

    init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let x = try? container.decode([String: JSONNull?].self) {
            self = .nullMap(x)
            return
        }
        if let x = try? container.decode([Int].self) {
            self = .integerArray(x)
            return
        }
        throw DecodingError.typeMismatch(Oskar.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Wrong type for Oskar"))
    }

    func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case .integerArray(let x):
            try container.encode(x)
        case .nullMap(let x):
            try container.encode(x)
        }
    }
}

enum Outrival: Codable {
    case double(Double)
    case nullMap([String: JSONNull?])
    case null

    init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let x = try? container.decode(Double.self) {
            self = .double(x)
            return
        }
        if let x = try? container.decode([String: JSONNull?].self) {
            self = .nullMap(x)
            return
        }
        if container.decodeNil() {
            self = .null
            return
        }
        throw DecodingError.typeMismatch(Outrival.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Wrong type for Outrival"))
    }

    func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case .double(let x):
            try container.encode(x)
        case .nullMap(let x):
            try container.encode(x)
        case .null:
            try container.encodeNil()
        }
    }
}

enum Paleographically: Codable {
    case double(Double)
    case unionMap([String: Int?])

    init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let x = try? container.decode(Double.self) {
            self = .double(x)
            return
        }
        if let x = try? container.decode([String: Int?].self) {
            self = .unionMap(x)
            return
        }
        throw DecodingError.typeMismatch(Paleographically.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Wrong type for Paleographically"))
    }

    func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case .double(let x):
            try container.encode(x)
        case .unionMap(let x):
            try container.encode(x)
        }
    }
}

enum Pamphletwise: Codable {
    case integer(Int)
    case integerMap([String: Int])
    case string(String)

    init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let x = try? container.decode(Int.self) {
            self = .integer(x)
            return
        }
        if let x = try? container.decode(String.self) {
            self = .string(x)
            return
        }
        if let x = try? container.decode([String: Int].self) {
            self = .integerMap(x)
            return
        }
        throw DecodingError.typeMismatch(Pamphletwise.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Wrong type for Pamphletwise"))
    }

    func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case .integer(let x):
            try container.encode(x)
        case .integerMap(let x):
            try container.encode(x)
        case .string(let x):
            try container.encode(x)
        }
    }
}

enum Pediatric: Codable {
    case bool(Bool)
    case double(Double)
    case null

    init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let x = try? container.decode(Bool.self) {
            self = .bool(x)
            return
        }
        if let x = try? container.decode(Double.self) {
            self = .double(x)
            return
        }
        if container.decodeNil() {
            self = .null
            return
        }
        throw DecodingError.typeMismatch(Pediatric.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Wrong type for Pediatric"))
    }

    func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case .bool(let x):
            try container.encode(x)
        case .double(let x):
            try container.encode(x)
        case .null:
            try container.encodeNil()
        }
    }
}

enum PiaculumUnion: Codable {
    case double(Double)
    case piaculumClass(PiaculumClass)

    init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let x = try? container.decode(Double.self) {
            self = .double(x)
            return
        }
        if let x = try? container.decode(PiaculumClass.self) {
            self = .piaculumClass(x)
            return
        }
        throw DecodingError.typeMismatch(PiaculumUnion.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Wrong type for PiaculumUnion"))
    }

    func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case .double(let x):
            try container.encode(x)
        case .piaculumClass(let x):
            try container.encode(x)
        }
    }
}

class PiaculumClass: Codable {
    let alada, amphistomous, boysenberry: Int?
    let catharticalness: Double?
    let chirotherium, decardinalize, discouragement: Int?
    let disdiapason: String?
    let doitrified, hexaspermous: Int?
    let homocerc: Bool?
    let insinking, loathfulness, miasmatical, neurofibril: Int?
    let nonbookish: JSONNull?
    let phonendoscope, pilferment, predismissory, preinscription: Int?
    let quotative, sienna, thorax, yachting: Int?
    let zipper: Int?

    enum CodingKeys: String, CodingKey {
        case alada, amphistomous, boysenberry, catharticalness
        case chirotherium = "Chirotherium"
        case decardinalize, discouragement, disdiapason, doitrified, hexaspermous, homocerc, insinking, loathfulness, miasmatical, neurofibril, nonbookish, phonendoscope, pilferment, predismissory, preinscription, quotative, sienna, thorax, yachting
        case zipper = "Zipper"
    }

    init(alada: Int?, amphistomous: Int?, boysenberry: Int?, catharticalness: Double?, chirotherium: Int?, decardinalize: Int?, discouragement: Int?, disdiapason: String?, doitrified: Int?, hexaspermous: Int?, homocerc: Bool?, insinking: Int?, loathfulness: Int?, miasmatical: Int?, neurofibril: Int?, nonbookish: JSONNull?, phonendoscope: Int?, pilferment: Int?, predismissory: Int?, preinscription: Int?, quotative: Int?, sienna: Int?, thorax: Int?, yachting: Int?, zipper: Int?) {
        self.alada = alada
        self.amphistomous = amphistomous
        self.boysenberry = boysenberry
        self.catharticalness = catharticalness
        self.chirotherium = chirotherium
        self.decardinalize = decardinalize
        self.discouragement = discouragement
        self.disdiapason = disdiapason
        self.doitrified = doitrified
        self.hexaspermous = hexaspermous
        self.homocerc = homocerc
        self.insinking = insinking
        self.loathfulness = loathfulness
        self.miasmatical = miasmatical
        self.neurofibril = neurofibril
        self.nonbookish = nonbookish
        self.phonendoscope = phonendoscope
        self.pilferment = pilferment
        self.predismissory = predismissory
        self.preinscription = preinscription
        self.quotative = quotative
        self.sienna = sienna
        self.thorax = thorax
        self.yachting = yachting
        self.zipper = zipper
    }
}

enum Piccadilly: Codable {
    case double(Double)
    case string(String)
    case null

    init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let x = try? container.decode(Double.self) {
            self = .double(x)
            return
        }
        if let x = try? container.decode(String.self) {
            self = .string(x)
            return
        }
        if container.decodeNil() {
            self = .null
            return
        }
        throw DecodingError.typeMismatch(Piccadilly.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Wrong type for Piccadilly"))
    }

    func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case .double(let x):
            try container.encode(x)
        case .string(let x):
            try container.encode(x)
        case .null:
            try container.encodeNil()
        }
    }
}

enum Piffler: Codable {
    case nullArray([JSONNull?])
    case rebeccaClass(RebeccaClass)

    init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let x = try? container.decode(RebeccaClass.self) {
            self = .rebeccaClass(x)
            return
        }
        if let x = try? container.decode([JSONNull?].self) {
            self = .nullArray(x)
            return
        }
        throw DecodingError.typeMismatch(Piffler.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Wrong type for Piffler"))
    }

    func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case .nullArray(let x):
            try container.encode(x)
        case .rebeccaClass(let x):
            try container.encode(x)
        }
    }
}

enum Pithful: Codable {
    case bool(Bool)
    case integer(Int)
    case null

    init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let x = try? container.decode(Bool.self) {
            self = .bool(x)
            return
        }
        if let x = try? container.decode(Int.self) {
            self = .integer(x)
            return
        }
        if container.decodeNil() {
            self = .null
            return
        }
        throw DecodingError.typeMismatch(Pithful.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Wrong type for Pithful"))
    }

    func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case .bool(let x):
            try container.encode(x)
        case .integer(let x):
            try container.encode(x)
        case .null:
            try container.encodeNil()
        }
    }
}

enum Placuntiti: Codable {
    case integer(Int)
    case integerMap([String: Int])

    init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let x = try? container.decode(Int.self) {
            self = .integer(x)
            return
        }
        if let x = try? container.decode([String: Int].self) {
            self = .integerMap(x)
            return
        }
        throw DecodingError.typeMismatch(Placuntiti.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Wrong type for Placuntiti"))
    }

    func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case .integer(let x):
            try container.encode(x)
        case .integerMap(let x):
            try container.encode(x)
        }
    }
}

class Pneumocele: Codable {
    let carbonarism: JSONNull?
    let catharticalness: Double?
    let chirotherium: Int?
    let cineolic, cobbly, conchyliferous, congregation: JSONNull?
    let disdiapason: String?
    let enterotomy, entophytal, fewtrils, herem: JSONNull?
    let homocerc: Bool?
    let koniga, meticulosity, micky, mismarriage: JSONNull?
    let neurotrophic, nonbookish, persuasively, replaceable: JSONNull?
    let silex, taillight, unjealous, visitorial: JSONNull?

    enum CodingKeys: String, CodingKey {
        case carbonarism = "Carbonarism"
        case catharticalness
        case chirotherium = "Chirotherium"
        case cineolic, cobbly, conchyliferous, congregation, disdiapason, enterotomy, entophytal, fewtrils, herem, homocerc
        case koniga = "Koniga"
        case meticulosity
        case micky = "Micky"
        case mismarriage, neurotrophic, nonbookish, persuasively, replaceable, silex, taillight, unjealous, visitorial
    }

    init(carbonarism: JSONNull?, catharticalness: Double?, chirotherium: Int?, cineolic: JSONNull?, cobbly: JSONNull?, conchyliferous: JSONNull?, congregation: JSONNull?, disdiapason: String?, enterotomy: JSONNull?, entophytal: JSONNull?, fewtrils: JSONNull?, herem: JSONNull?, homocerc: Bool?, koniga: JSONNull?, meticulosity: JSONNull?, micky: JSONNull?, mismarriage: JSONNull?, neurotrophic: JSONNull?, nonbookish: JSONNull?, persuasively: JSONNull?, replaceable: JSONNull?, silex: JSONNull?, taillight: JSONNull?, unjealous: JSONNull?, visitorial: JSONNull?) {
        self.carbonarism = carbonarism
        self.catharticalness = catharticalness
        self.chirotherium = chirotherium
        self.cineolic = cineolic
        self.cobbly = cobbly
        self.conchyliferous = conchyliferous
        self.congregation = congregation
        self.disdiapason = disdiapason
        self.enterotomy = enterotomy
        self.entophytal = entophytal
        self.fewtrils = fewtrils
        self.herem = herem
        self.homocerc = homocerc
        self.koniga = koniga
        self.meticulosity = meticulosity
        self.micky = micky
        self.mismarriage = mismarriage
        self.neurotrophic = neurotrophic
        self.nonbookish = nonbookish
        self.persuasively = persuasively
        self.replaceable = replaceable
        self.silex = silex
        self.taillight = taillight
        self.unjealous = unjealous
        self.visitorial = visitorial
    }
}

enum Poliorcetic: Codable {
    case bool(Bool)
    case rebeccaClass(RebeccaClass)

    init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let x = try? container.decode(Bool.self) {
            self = .bool(x)
            return
        }
        if let x = try? container.decode(RebeccaClass.self) {
            self = .rebeccaClass(x)
            return
        }
        throw DecodingError.typeMismatch(Poliorcetic.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Wrong type for Poliorcetic"))
    }

    func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case .bool(let x):
            try container.encode(x)
        case .rebeccaClass(let x):
            try container.encode(x)
        }
    }
}

enum Poormaster: Codable {
    case integerArray([Int])
    case integerMap([String: Int])
    case null

    init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let x = try? container.decode([String: Int].self) {
            self = .integerMap(x)
            return
        }
        if let x = try? container.decode([Int].self) {
            self = .integerArray(x)
            return
        }
        if container.decodeNil() {
            self = .null
            return
        }
        throw DecodingError.typeMismatch(Poormaster.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Wrong type for Poormaster"))
    }

    func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case .integerArray(let x):
            try container.encode(x)
        case .integerMap(let x):
            try container.encode(x)
        case .null:
            try container.encodeNil()
        }
    }
}

enum Potwhisky: Codable {
    case integer(Int)
    case nullMap([String: JSONNull?])
    case null

    init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let x = try? container.decode(Int.self) {
            self = .integer(x)
            return
        }
        if let x = try? container.decode([String: JSONNull?].self) {
            self = .nullMap(x)
            return
        }
        if container.decodeNil() {
            self = .null
            return
        }
        throw DecodingError.typeMismatch(Potwhisky.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Wrong type for Potwhisky"))
    }

    func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case .integer(let x):
            try container.encode(x)
        case .nullMap(let x):
            try container.encode(x)
        case .null:
            try container.encodeNil()
        }
    }
}

enum Practicalizer: Codable {
    case nullArray([JSONNull?])
    case rebeccaClass(RebeccaClass)
    case string(String)

    init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let x = try? container.decode(String.self) {
            self = .string(x)
            return
        }
        if let x = try? container.decode(RebeccaClass.self) {
            self = .rebeccaClass(x)
            return
        }
        if let x = try? container.decode([JSONNull?].self) {
            self = .nullArray(x)
            return
        }
        throw DecodingError.typeMismatch(Practicalizer.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Wrong type for Practicalizer"))
    }

    func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case .nullArray(let x):
            try container.encode(x)
        case .rebeccaClass(let x):
            try container.encode(x)
        case .string(let x):
            try container.encode(x)
        }
    }
}

enum Prefreshman: Codable {
    case nullArray([JSONNull?])
    case nullMap([String: JSONNull?])
    case string(String)

    init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let x = try? container.decode(String.self) {
            self = .string(x)
            return
        }
        if let x = try? container.decode([String: JSONNull?].self) {
            self = .nullMap(x)
            return
        }
        if let x = try? container.decode([JSONNull?].self) {
            self = .nullArray(x)
            return
        }
        throw DecodingError.typeMismatch(Prefreshman.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Wrong type for Prefreshman"))
    }

    func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case .nullArray(let x):
            try container.encode(x)
        case .nullMap(let x):
            try container.encode(x)
        case .string(let x):
            try container.encode(x)
        }
    }
}

enum Prehensility: Codable {
    case bool(Bool)
    case nullArray([JSONNull?])
    case rebeccaClass(RebeccaClass)

    init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let x = try? container.decode(Bool.self) {
            self = .bool(x)
            return
        }
        if let x = try? container.decode(RebeccaClass.self) {
            self = .rebeccaClass(x)
            return
        }
        if let x = try? container.decode([JSONNull?].self) {
            self = .nullArray(x)
            return
        }
        throw DecodingError.typeMismatch(Prehensility.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Wrong type for Prehensility"))
    }

    func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case .bool(let x):
            try container.encode(x)
        case .nullArray(let x):
            try container.encode(x)
        case .rebeccaClass(let x):
            try container.encode(x)
        }
    }
}

enum Prevoidance: Codable {
    case integer(Int)
    case integerArray([Int])
    case rebeccaClass(RebeccaClass)

    init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let x = try? container.decode(Int.self) {
            self = .integer(x)
            return
        }
        if let x = try? container.decode(RebeccaClass.self) {
            self = .rebeccaClass(x)
            return
        }
        if let x = try? container.decode([Int].self) {
            self = .integerArray(x)
            return
        }
        throw DecodingError.typeMismatch(Prevoidance.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Wrong type for Prevoidance"))
    }

    func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case .integer(let x):
            try container.encode(x)
        case .integerArray(let x):
            try container.encode(x)
        case .rebeccaClass(let x):
            try container.encode(x)
        }
    }
}

enum Protext: Codable {
    case bool(Bool)
    case integerArray([Int])
    case rebeccaClass(RebeccaClass)

    init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let x = try? container.decode(Bool.self) {
            self = .bool(x)
            return
        }
        if let x = try? container.decode(RebeccaClass.self) {
            self = .rebeccaClass(x)
            return
        }
        if let x = try? container.decode([Int].self) {
            self = .integerArray(x)
            return
        }
        throw DecodingError.typeMismatch(Protext.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Wrong type for Protext"))
    }

    func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case .bool(let x):
            try container.encode(x)
        case .integerArray(let x):
            try container.encode(x)
        case .rebeccaClass(let x):
            try container.encode(x)
        }
    }
}

enum Protrusive: Codable {
    case double(Double)
    case unionArray([Int?])

    init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let x = try? container.decode(Double.self) {
            self = .double(x)
            return
        }
        if let x = try? container.decode([Int?].self) {
            self = .unionArray(x)
            return
        }
        throw DecodingError.typeMismatch(Protrusive.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Wrong type for Protrusive"))
    }

    func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case .double(let x):
            try container.encode(x)
        case .unionArray(let x):
            try container.encode(x)
        }
    }
}

enum Pulpitism: Codable {
    case double(Double)
    case integerArray([Int])
    case nullMap([String: JSONNull?])

    init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let x = try? container.decode(Double.self) {
            self = .double(x)
            return
        }
        if let x = try? container.decode([String: JSONNull?].self) {
            self = .nullMap(x)
            return
        }
        if let x = try? container.decode([Int].self) {
            self = .integerArray(x)
            return
        }
        throw DecodingError.typeMismatch(Pulpitism.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Wrong type for Pulpitism"))
    }

    func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case .double(let x):
            try container.encode(x)
        case .integerArray(let x):
            try container.encode(x)
        case .nullMap(let x):
            try container.encode(x)
        }
    }
}

enum Pyodermia: Codable {
    case integer(Int)
    case nullMap([String: JSONNull?])

    init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let x = try? container.decode(Int.self) {
            self = .integer(x)
            return
        }
        if let x = try? container.decode([String: JSONNull?].self) {
            self = .nullMap(x)
            return
        }
        throw DecodingError.typeMismatch(Pyodermia.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Wrong type for Pyodermia"))
    }

    func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case .integer(let x):
            try container.encode(x)
        case .nullMap(let x):
            try container.encode(x)
        }
    }
}

enum Quebrachine: Codable {
    case bool(Bool)
    case rebeccaClass(RebeccaClass)
    case null

    init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let x = try? container.decode(Bool.self) {
            self = .bool(x)
            return
        }
        if let x = try? container.decode(RebeccaClass.self) {
            self = .rebeccaClass(x)
            return
        }
        if container.decodeNil() {
            self = .null
            return
        }
        throw DecodingError.typeMismatch(Quebrachine.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Wrong type for Quebrachine"))
    }

    func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case .bool(let x):
            try container.encode(x)
        case .rebeccaClass(let x):
            try container.encode(x)
        case .null:
            try container.encodeNil()
        }
    }
}

enum Querier: Codable {
    case bool(Bool)
    case integerMap([String: Int])

    init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let x = try? container.decode(Bool.self) {
            self = .bool(x)
            return
        }
        if let x = try? container.decode([String: Int].self) {
            self = .integerMap(x)
            return
        }
        throw DecodingError.typeMismatch(Querier.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Wrong type for Querier"))
    }

    func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case .bool(let x):
            try container.encode(x)
        case .integerMap(let x):
            try container.encode(x)
        }
    }
}

enum Rebarbative: Codable {
    case bool(Bool)
    case double(Double)
    case integerArray([Int])

    init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let x = try? container.decode(Bool.self) {
            self = .bool(x)
            return
        }
        if let x = try? container.decode(Double.self) {
            self = .double(x)
            return
        }
        if let x = try? container.decode([Int].self) {
            self = .integerArray(x)
            return
        }
        throw DecodingError.typeMismatch(Rebarbative.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Wrong type for Rebarbative"))
    }

    func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case .bool(let x):
            try container.encode(x)
        case .double(let x):
            try container.encode(x)
        case .integerArray(let x):
            try container.encode(x)
        }
    }
}

enum RebeccaUnion: Codable {
    case integer(Int)
    case rebeccaClass(RebeccaClass)
    case string(String)

    init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let x = try? container.decode(Int.self) {
            self = .integer(x)
            return
        }
        if let x = try? container.decode(String.self) {
            self = .string(x)
            return
        }
        if let x = try? container.decode(RebeccaClass.self) {
            self = .rebeccaClass(x)
            return
        }
        throw DecodingError.typeMismatch(RebeccaUnion.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Wrong type for RebeccaUnion"))
    }

    func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case .integer(let x):
            try container.encode(x)
        case .rebeccaClass(let x):
            try container.encode(x)
        case .string(let x):
            try container.encode(x)
        }
    }
}

class Reimagine: Codable {
    let adducible, anabolin, brainy: JSONNull?
    let catharticalness: Double?
    let chirotherium: Int?
    let chrysamine: JSONNull?
    let disdiapason: String?
    let fluxweed, glaucine, grobianism, hermo: JSONNull?
    let hieroglyphist: JSONNull?
    let homocerc: Bool?
    let icteroid, immortal, impetulant, irrigate: JSONNull?
    let myxedema, nonbookish, onyx, repasser: JSONNull?
    let septomarginal, subdie, tibiometatarsal, waltzlike: JSONNull?

    enum CodingKeys: String, CodingKey {
        case adducible, anabolin, brainy, catharticalness
        case chirotherium = "Chirotherium"
        case chrysamine, disdiapason, fluxweed, glaucine, grobianism
        case hermo = "Hermo"
        case hieroglyphist, homocerc, icteroid, immortal, impetulant, irrigate, myxedema, nonbookish, onyx, repasser, septomarginal, subdie, tibiometatarsal, waltzlike
    }

    init(adducible: JSONNull?, anabolin: JSONNull?, brainy: JSONNull?, catharticalness: Double?, chirotherium: Int?, chrysamine: JSONNull?, disdiapason: String?, fluxweed: JSONNull?, glaucine: JSONNull?, grobianism: JSONNull?, hermo: JSONNull?, hieroglyphist: JSONNull?, homocerc: Bool?, icteroid: JSONNull?, immortal: JSONNull?, impetulant: JSONNull?, irrigate: JSONNull?, myxedema: JSONNull?, nonbookish: JSONNull?, onyx: JSONNull?, repasser: JSONNull?, septomarginal: JSONNull?, subdie: JSONNull?, tibiometatarsal: JSONNull?, waltzlike: JSONNull?) {
        self.adducible = adducible
        self.anabolin = anabolin
        self.brainy = brainy
        self.catharticalness = catharticalness
        self.chirotherium = chirotherium
        self.chrysamine = chrysamine
        self.disdiapason = disdiapason
        self.fluxweed = fluxweed
        self.glaucine = glaucine
        self.grobianism = grobianism
        self.hermo = hermo
        self.hieroglyphist = hieroglyphist
        self.homocerc = homocerc
        self.icteroid = icteroid
        self.immortal = immortal
        self.impetulant = impetulant
        self.irrigate = irrigate
        self.myxedema = myxedema
        self.nonbookish = nonbookish
        self.onyx = onyx
        self.repasser = repasser
        self.septomarginal = septomarginal
        self.subdie = subdie
        self.tibiometatarsal = tibiometatarsal
        self.waltzlike = waltzlike
    }
}

enum Retrocervical: Codable {
    case integer(Int)
    case unionArray([Int?])

    init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let x = try? container.decode(Int.self) {
            self = .integer(x)
            return
        }
        if let x = try? container.decode([Int?].self) {
            self = .unionArray(x)
            return
        }
        throw DecodingError.typeMismatch(Retrocervical.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Wrong type for Retrocervical"))
    }

    func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case .integer(let x):
            try container.encode(x)
        case .unionArray(let x):
            try container.encode(x)
        }
    }
}

enum Revert: Codable {
    case bool(Bool)
    case string(String)

    init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let x = try? container.decode(Bool.self) {
            self = .bool(x)
            return
        }
        if let x = try? container.decode(String.self) {
            self = .string(x)
            return
        }
        throw DecodingError.typeMismatch(Revert.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Wrong type for Revert"))
    }

    func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case .bool(let x):
            try container.encode(x)
        case .string(let x):
            try container.encode(x)
        }
    }
}

enum Rewrite: Codable {
    case double(Double)
    case nullArray([JSONNull?])
    case nullMap([String: JSONNull?])

    init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let x = try? container.decode(Double.self) {
            self = .double(x)
            return
        }
        if let x = try? container.decode([String: JSONNull?].self) {
            self = .nullMap(x)
            return
        }
        if let x = try? container.decode([JSONNull?].self) {
            self = .nullArray(x)
            return
        }
        throw DecodingError.typeMismatch(Rewrite.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Wrong type for Rewrite"))
    }

    func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case .double(let x):
            try container.encode(x)
        case .nullArray(let x):
            try container.encode(x)
        case .nullMap(let x):
            try container.encode(x)
        }
    }
}

enum Rhomboganoidei: Codable {
    case integerArray([Int])
    case rebeccaClass(RebeccaClass)
    case string(String)

    init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let x = try? container.decode(String.self) {
            self = .string(x)
            return
        }
        if let x = try? container.decode(RebeccaClass.self) {
            self = .rebeccaClass(x)
            return
        }
        if let x = try? container.decode([Int].self) {
            self = .integerArray(x)
            return
        }
        throw DecodingError.typeMismatch(Rhomboganoidei.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Wrong type for Rhomboganoidei"))
    }

    func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case .integerArray(let x):
            try container.encode(x)
        case .rebeccaClass(let x):
            try container.encode(x)
        case .string(let x):
            try container.encode(x)
        }
    }
}

enum Ruellia: Codable {
    case bool(Bool)
    case rebeccaClass(RebeccaClass)
    case string(String)

    init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let x = try? container.decode(Bool.self) {
            self = .bool(x)
            return
        }
        if let x = try? container.decode(String.self) {
            self = .string(x)
            return
        }
        if let x = try? container.decode(RebeccaClass.self) {
            self = .rebeccaClass(x)
            return
        }
        throw DecodingError.typeMismatch(Ruellia.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Wrong type for Ruellia"))
    }

    func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case .bool(let x):
            try container.encode(x)
        case .rebeccaClass(let x):
            try container.encode(x)
        case .string(let x):
            try container.encode(x)
        }
    }
}

enum Saccoderm: Codable {
    case integerArray([Int])
    case string(String)
    case null

    init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let x = try? container.decode(String.self) {
            self = .string(x)
            return
        }
        if let x = try? container.decode([Int].self) {
            self = .integerArray(x)
            return
        }
        if container.decodeNil() {
            self = .null
            return
        }
        throw DecodingError.typeMismatch(Saccoderm.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Wrong type for Saccoderm"))
    }

    func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case .integerArray(let x):
            try container.encode(x)
        case .string(let x):
            try container.encode(x)
        case .null:
            try container.encodeNil()
        }
    }
}

enum Saprophilous: Codable {
    case integerMap([String: Int])
    case string(String)
    case null

    init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let x = try? container.decode(String.self) {
            self = .string(x)
            return
        }
        if let x = try? container.decode([String: Int].self) {
            self = .integerMap(x)
            return
        }
        if container.decodeNil() {
            self = .null
            return
        }
        throw DecodingError.typeMismatch(Saprophilous.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Wrong type for Saprophilous"))
    }

    func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case .integerMap(let x):
            try container.encode(x)
        case .string(let x):
            try container.encode(x)
        case .null:
            try container.encodeNil()
        }
    }
}

enum SaxtenUnion: Codable {
    case saxtenClass(SaxtenClass)
    case string(String)

    init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let x = try? container.decode(String.self) {
            self = .string(x)
            return
        }
        if let x = try? container.decode(SaxtenClass.self) {
            self = .saxtenClass(x)
            return
        }
        throw DecodingError.typeMismatch(SaxtenUnion.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Wrong type for SaxtenUnion"))
    }

    func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case .saxtenClass(let x):
            try container.encode(x)
        case .string(let x):
            try container.encode(x)
        }
    }
}

class SaxtenClass: Codable {
    let algarrobilla, bowgrace: JSONNull?
    let catharticalness: Double?
    let centaurid: JSONNull?
    let chirotherium: Int?
    let disdiapason: String?
    let flix, germanely: JSONNull?
    let homocerc: Bool?
    let inhume, lepidote, megalochirous, ninepenny: JSONNull?
    let nonbookish, nondeist, nymphaeaceous, parietofrontal: JSONNull?
    let sancyite, subjectivist, tibiad, transonic: JSONNull?
    let tripetalous, trunchman, urger, withdrawnness: JSONNull?

    enum CodingKeys: String, CodingKey {
        case algarrobilla, bowgrace, catharticalness
        case centaurid = "Centaurid"
        case chirotherium = "Chirotherium"
        case disdiapason, flix, germanely, homocerc, inhume, lepidote, megalochirous, ninepenny, nonbookish, nondeist, nymphaeaceous, parietofrontal, sancyite, subjectivist, tibiad, transonic, tripetalous, trunchman, urger, withdrawnness
    }

    init(algarrobilla: JSONNull?, bowgrace: JSONNull?, catharticalness: Double?, centaurid: JSONNull?, chirotherium: Int?, disdiapason: String?, flix: JSONNull?, germanely: JSONNull?, homocerc: Bool?, inhume: JSONNull?, lepidote: JSONNull?, megalochirous: JSONNull?, ninepenny: JSONNull?, nonbookish: JSONNull?, nondeist: JSONNull?, nymphaeaceous: JSONNull?, parietofrontal: JSONNull?, sancyite: JSONNull?, subjectivist: JSONNull?, tibiad: JSONNull?, transonic: JSONNull?, tripetalous: JSONNull?, trunchman: JSONNull?, urger: JSONNull?, withdrawnness: JSONNull?) {
        self.algarrobilla = algarrobilla
        self.bowgrace = bowgrace
        self.catharticalness = catharticalness
        self.centaurid = centaurid
        self.chirotherium = chirotherium
        self.disdiapason = disdiapason
        self.flix = flix
        self.germanely = germanely
        self.homocerc = homocerc
        self.inhume = inhume
        self.lepidote = lepidote
        self.megalochirous = megalochirous
        self.ninepenny = ninepenny
        self.nonbookish = nonbookish
        self.nondeist = nondeist
        self.nymphaeaceous = nymphaeaceous
        self.parietofrontal = parietofrontal
        self.sancyite = sancyite
        self.subjectivist = subjectivist
        self.tibiad = tibiad
        self.transonic = transonic
        self.tripetalous = tripetalous
        self.trunchman = trunchman
        self.urger = urger
        self.withdrawnness = withdrawnness
    }
}

enum School: Codable {
    case integer(Int)
    case integerMap([String: Int])
    case null

    init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let x = try? container.decode(Int.self) {
            self = .integer(x)
            return
        }
        if let x = try? container.decode([String: Int].self) {
            self = .integerMap(x)
            return
        }
        if container.decodeNil() {
            self = .null
            return
        }
        throw DecodingError.typeMismatch(School.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Wrong type for School"))
    }

    func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case .integer(let x):
            try container.encode(x)
        case .integerMap(let x):
            try container.encode(x)
        case .null:
            try container.encodeNil()
        }
    }
}

enum Scoffer: Codable {
    case integerMap([String: Int])
    case nullArray([JSONNull?])
    case null

    init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let x = try? container.decode([String: Int].self) {
            self = .integerMap(x)
            return
        }
        if let x = try? container.decode([JSONNull?].self) {
            self = .nullArray(x)
            return
        }
        if container.decodeNil() {
            self = .null
            return
        }
        throw DecodingError.typeMismatch(Scoffer.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Wrong type for Scoffer"))
    }

    func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case .integerMap(let x):
            try container.encode(x)
        case .nullArray(let x):
            try container.encode(x)
        case .null:
            try container.encodeNil()
        }
    }
}

enum Scrampum: Codable {
    case bool(Bool)
    case integerArray([Int])
    case null

    init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let x = try? container.decode(Bool.self) {
            self = .bool(x)
            return
        }
        if let x = try? container.decode([Int].self) {
            self = .integerArray(x)
            return
        }
        if container.decodeNil() {
            self = .null
            return
        }
        throw DecodingError.typeMismatch(Scrampum.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Wrong type for Scrampum"))
    }

    func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case .bool(let x):
            try container.encode(x)
        case .integerArray(let x):
            try container.encode(x)
        case .null:
            try container.encodeNil()
        }
    }
}

enum Shadowable: Codable {
    case bool(Bool)
    case unionArray([Int?])

    init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let x = try? container.decode(Bool.self) {
            self = .bool(x)
            return
        }
        if let x = try? container.decode([Int?].self) {
            self = .unionArray(x)
            return
        }
        throw DecodingError.typeMismatch(Shadowable.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Wrong type for Shadowable"))
    }

    func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case .bool(let x):
            try container.encode(x)
        case .unionArray(let x):
            try container.encode(x)
        }
    }
}

enum Shakespearolater: Codable {
    case double(Double)
    case integerArray([Int])
    case string(String)

    init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let x = try? container.decode(Double.self) {
            self = .double(x)
            return
        }
        if let x = try? container.decode(String.self) {
            self = .string(x)
            return
        }
        if let x = try? container.decode([Int].self) {
            self = .integerArray(x)
            return
        }
        throw DecodingError.typeMismatch(Shakespearolater.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Wrong type for Shakespearolater"))
    }

    func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case .double(let x):
            try container.encode(x)
        case .integerArray(let x):
            try container.encode(x)
        case .string(let x):
            try container.encode(x)
        }
    }
}

enum Sistering: Codable {
    case integer(Int)
    case nullArray([JSONNull?])
    case nullMap([String: JSONNull?])

    init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let x = try? container.decode(Int.self) {
            self = .integer(x)
            return
        }
        if let x = try? container.decode([String: JSONNull?].self) {
            self = .nullMap(x)
            return
        }
        if let x = try? container.decode([JSONNull?].self) {
            self = .nullArray(x)
            return
        }
        throw DecodingError.typeMismatch(Sistering.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Wrong type for Sistering"))
    }

    func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case .integer(let x):
            try container.encode(x)
        case .nullArray(let x):
            try container.encode(x)
        case .nullMap(let x):
            try container.encode(x)
        }
    }
}

class Staghunting: Codable {
    let calorimetric, canid: Int?
    let catharticalness: Double?
    let chirotherium: Int?
    let disdiapason: String?
    let ditriglyphic, floriferousness, gamelike, grig: Int?
    let homocerc: Bool?
    let interloan, lithotomy, loric, membranocoriaceous: Int?
    let membranogenic: Int?
    let nonbookish: JSONNull?
    let overtrump, scotino, seasonable, sephen: Int?
    let stigmarioid, tired, trifid, undefeatedly: Int?
    let ungirlish: Int?

    enum CodingKeys: String, CodingKey {
        case calorimetric, canid, catharticalness
        case chirotherium = "Chirotherium"
        case disdiapason, ditriglyphic, floriferousness, gamelike, grig, homocerc, interloan, lithotomy, loric, membranocoriaceous, membranogenic, nonbookish, overtrump, scotino, seasonable, sephen, stigmarioid, tired, trifid, undefeatedly, ungirlish
    }

    init(calorimetric: Int?, canid: Int?, catharticalness: Double?, chirotherium: Int?, disdiapason: String?, ditriglyphic: Int?, floriferousness: Int?, gamelike: Int?, grig: Int?, homocerc: Bool?, interloan: Int?, lithotomy: Int?, loric: Int?, membranocoriaceous: Int?, membranogenic: Int?, nonbookish: JSONNull?, overtrump: Int?, scotino: Int?, seasonable: Int?, sephen: Int?, stigmarioid: Int?, tired: Int?, trifid: Int?, undefeatedly: Int?, ungirlish: Int?) {
        self.calorimetric = calorimetric
        self.canid = canid
        self.catharticalness = catharticalness
        self.chirotherium = chirotherium
        self.disdiapason = disdiapason
        self.ditriglyphic = ditriglyphic
        self.floriferousness = floriferousness
        self.gamelike = gamelike
        self.grig = grig
        self.homocerc = homocerc
        self.interloan = interloan
        self.lithotomy = lithotomy
        self.loric = loric
        self.membranocoriaceous = membranocoriaceous
        self.membranogenic = membranogenic
        self.nonbookish = nonbookish
        self.overtrump = overtrump
        self.scotino = scotino
        self.seasonable = seasonable
        self.sephen = sephen
        self.stigmarioid = stigmarioid
        self.tired = tired
        self.trifid = trifid
        self.undefeatedly = undefeatedly
        self.ungirlish = ungirlish
    }
}

enum Stagmometer: Codable {
    case string(String)
    case unionArray([Int?])

    init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let x = try? container.decode(String.self) {
            self = .string(x)
            return
        }
        if let x = try? container.decode([Int?].self) {
            self = .unionArray(x)
            return
        }
        throw DecodingError.typeMismatch(Stagmometer.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Wrong type for Stagmometer"))
    }

    func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case .string(let x):
            try container.encode(x)
        case .unionArray(let x):
            try container.encode(x)
        }
    }
}

enum Stimulability: Codable {
    case bool(Bool)
    case integer(Int)
    case integerMap([String: Int])

    init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let x = try? container.decode(Bool.self) {
            self = .bool(x)
            return
        }
        if let x = try? container.decode(Int.self) {
            self = .integer(x)
            return
        }
        if let x = try? container.decode([String: Int].self) {
            self = .integerMap(x)
            return
        }
        throw DecodingError.typeMismatch(Stimulability.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Wrong type for Stimulability"))
    }

    func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case .bool(let x):
            try container.encode(x)
        case .integer(let x):
            try container.encode(x)
        case .integerMap(let x):
            try container.encode(x)
        }
    }
}

enum StrenuosityUnion: Codable {
    case nullArray([JSONNull?])
    case strenuosityClass(StrenuosityClass)

    init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let x = try? container.decode(StrenuosityClass.self) {
            self = .strenuosityClass(x)
            return
        }
        if let x = try? container.decode([JSONNull?].self) {
            self = .nullArray(x)
            return
        }
        throw DecodingError.typeMismatch(StrenuosityUnion.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Wrong type for StrenuosityUnion"))
    }

    func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case .nullArray(let x):
            try container.encode(x)
        case .strenuosityClass(let x):
            try container.encode(x)
        }
    }
}

class StrenuosityClass: Codable {
    let bliss, buccate, bulletproof: Int?
    let catharticalness: Double?
    let chirotherium, crumblingness: Int?
    let disdiapason: String?
    let engagedly, fightable, hoariness: Int?
    let homocerc: Bool?
    let hypopodium, luxurist, mechanician: Int?
    let nonbookish: JSONNull?
    let onopordon, podgily, reformableness, scatterbrains: Int?
    let seminuria, sodomite, tramp, undueness: Int?
    let worthily, yankeeist: Int?

    enum CodingKeys: String, CodingKey {
        case bliss, buccate, bulletproof, catharticalness
        case chirotherium = "Chirotherium"
        case crumblingness, disdiapason, engagedly, fightable, hoariness, homocerc, hypopodium, luxurist, mechanician, nonbookish
        case onopordon = "Onopordon"
        case podgily, reformableness, scatterbrains, seminuria
        case sodomite = "Sodomite"
        case tramp, undueness, worthily
        case yankeeist = "Yankeeist"
    }

    init(bliss: Int?, buccate: Int?, bulletproof: Int?, catharticalness: Double?, chirotherium: Int?, crumblingness: Int?, disdiapason: String?, engagedly: Int?, fightable: Int?, hoariness: Int?, homocerc: Bool?, hypopodium: Int?, luxurist: Int?, mechanician: Int?, nonbookish: JSONNull?, onopordon: Int?, podgily: Int?, reformableness: Int?, scatterbrains: Int?, seminuria: Int?, sodomite: Int?, tramp: Int?, undueness: Int?, worthily: Int?, yankeeist: Int?) {
        self.bliss = bliss
        self.buccate = buccate
        self.bulletproof = bulletproof
        self.catharticalness = catharticalness
        self.chirotherium = chirotherium
        self.crumblingness = crumblingness
        self.disdiapason = disdiapason
        self.engagedly = engagedly
        self.fightable = fightable
        self.hoariness = hoariness
        self.homocerc = homocerc
        self.hypopodium = hypopodium
        self.luxurist = luxurist
        self.mechanician = mechanician
        self.nonbookish = nonbookish
        self.onopordon = onopordon
        self.podgily = podgily
        self.reformableness = reformableness
        self.scatterbrains = scatterbrains
        self.seminuria = seminuria
        self.sodomite = sodomite
        self.tramp = tramp
        self.undueness = undueness
        self.worthily = worthily
        self.yankeeist = yankeeist
    }
}

enum Talpiform: Codable {
    case double(Double)
    case rebeccaClass(RebeccaClass)
    case null

    init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let x = try? container.decode(Double.self) {
            self = .double(x)
            return
        }
        if let x = try? container.decode(RebeccaClass.self) {
            self = .rebeccaClass(x)
            return
        }
        if container.decodeNil() {
            self = .null
            return
        }
        throw DecodingError.typeMismatch(Talpiform.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Wrong type for Talpiform"))
    }

    func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case .double(let x):
            try container.encode(x)
        case .rebeccaClass(let x):
            try container.encode(x)
        case .null:
            try container.encodeNil()
        }
    }
}

enum Thwack: Codable {
    case bool(Bool)
    case double(Double)
    case rebeccaClass(RebeccaClass)

    init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let x = try? container.decode(Bool.self) {
            self = .bool(x)
            return
        }
        if let x = try? container.decode(Double.self) {
            self = .double(x)
            return
        }
        if let x = try? container.decode(RebeccaClass.self) {
            self = .rebeccaClass(x)
            return
        }
        throw DecodingError.typeMismatch(Thwack.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Wrong type for Thwack"))
    }

    func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case .bool(let x):
            try container.encode(x)
        case .double(let x):
            try container.encode(x)
        case .rebeccaClass(let x):
            try container.encode(x)
        }
    }
}

enum Tortricine: Codable {
    case rebeccaClass(RebeccaClass)
    case unionArray([Int?])

    init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let x = try? container.decode(RebeccaClass.self) {
            self = .rebeccaClass(x)
            return
        }
        if let x = try? container.decode([Int?].self) {
            self = .unionArray(x)
            return
        }
        throw DecodingError.typeMismatch(Tortricine.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Wrong type for Tortricine"))
    }

    func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case .rebeccaClass(let x):
            try container.encode(x)
        case .unionArray(let x):
            try container.encode(x)
        }
    }
}

enum TruantcyUnion: Codable {
    case bool(Bool)
    case truantcyClass(TruantcyClass)

    init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let x = try? container.decode(Bool.self) {
            self = .bool(x)
            return
        }
        if let x = try? container.decode(TruantcyClass.self) {
            self = .truantcyClass(x)
            return
        }
        throw DecodingError.typeMismatch(TruantcyUnion.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Wrong type for TruantcyUnion"))
    }

    func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case .bool(let x):
            try container.encode(x)
        case .truantcyClass(let x):
            try container.encode(x)
        }
    }
}

class TruantcyClass: Codable {
    let alfiona, ascaridiasis, bungey: JSONNull?
    let catharticalness: Double?
    let ceroxyle: JSONNull?
    let chirotherium: Int?
    let chorology: JSONNull?
    let disdiapason: String?
    let enmarble, epeira, eurylaimi, germination: JSONNull?
    let hallelujah: JSONNull?
    let homocerc: Bool?
    let lev, mouthing, nonbookish, philliloo: JSONNull?
    let planetal, poney, punctualist, returnlessly: JSONNull?
    let skelder, windwaywardly, yuman: JSONNull?

    enum CodingKeys: String, CodingKey {
        case alfiona, ascaridiasis, bungey, catharticalness, ceroxyle
        case chirotherium = "Chirotherium"
        case chorology, disdiapason, enmarble
        case epeira = "Epeira"
        case eurylaimi = "Eurylaimi"
        case germination, hallelujah, homocerc, lev, mouthing, nonbookish, philliloo, planetal, poney, punctualist, returnlessly, skelder, windwaywardly
        case yuman = "Yuman"
    }

    init(alfiona: JSONNull?, ascaridiasis: JSONNull?, bungey: JSONNull?, catharticalness: Double?, ceroxyle: JSONNull?, chirotherium: Int?, chorology: JSONNull?, disdiapason: String?, enmarble: JSONNull?, epeira: JSONNull?, eurylaimi: JSONNull?, germination: JSONNull?, hallelujah: JSONNull?, homocerc: Bool?, lev: JSONNull?, mouthing: JSONNull?, nonbookish: JSONNull?, philliloo: JSONNull?, planetal: JSONNull?, poney: JSONNull?, punctualist: JSONNull?, returnlessly: JSONNull?, skelder: JSONNull?, windwaywardly: JSONNull?, yuman: JSONNull?) {
        self.alfiona = alfiona
        self.ascaridiasis = ascaridiasis
        self.bungey = bungey
        self.catharticalness = catharticalness
        self.ceroxyle = ceroxyle
        self.chirotherium = chirotherium
        self.chorology = chorology
        self.disdiapason = disdiapason
        self.enmarble = enmarble
        self.epeira = epeira
        self.eurylaimi = eurylaimi
        self.germination = germination
        self.hallelujah = hallelujah
        self.homocerc = homocerc
        self.lev = lev
        self.mouthing = mouthing
        self.nonbookish = nonbookish
        self.philliloo = philliloo
        self.planetal = planetal
        self.poney = poney
        self.punctualist = punctualist
        self.returnlessly = returnlessly
        self.skelder = skelder
        self.windwaywardly = windwaywardly
        self.yuman = yuman
    }
}

enum Unbeginning: Codable {
    case integerMap([String: Int])
    case nullArray([JSONNull?])
    case string(String)

    init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let x = try? container.decode(String.self) {
            self = .string(x)
            return
        }
        if let x = try? container.decode([String: Int].self) {
            self = .integerMap(x)
            return
        }
        if let x = try? container.decode([JSONNull?].self) {
            self = .nullArray(x)
            return
        }
        throw DecodingError.typeMismatch(Unbeginning.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Wrong type for Unbeginning"))
    }

    func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case .integerMap(let x):
            try container.encode(x)
        case .nullArray(let x):
            try container.encode(x)
        case .string(let x):
            try container.encode(x)
        }
    }
}

enum Undesirability: Codable {
    case integerArray([Int])
    case integerMap([String: Int])
    case string(String)

    init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let x = try? container.decode(String.self) {
            self = .string(x)
            return
        }
        if let x = try? container.decode([String: Int].self) {
            self = .integerMap(x)
            return
        }
        if let x = try? container.decode([Int].self) {
            self = .integerArray(x)
            return
        }
        throw DecodingError.typeMismatch(Undesirability.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Wrong type for Undesirability"))
    }

    func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case .integerArray(let x):
            try container.encode(x)
        case .integerMap(let x):
            try container.encode(x)
        case .string(let x):
            try container.encode(x)
        }
    }
}

enum Unerasing: Codable {
    case integer(Int)
    case integerMap([String: Int])
    case nullArray([JSONNull?])

    init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let x = try? container.decode(Int.self) {
            self = .integer(x)
            return
        }
        if let x = try? container.decode([String: Int].self) {
            self = .integerMap(x)
            return
        }
        if let x = try? container.decode([JSONNull?].self) {
            self = .nullArray(x)
            return
        }
        throw DecodingError.typeMismatch(Unerasing.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Wrong type for Unerasing"))
    }

    func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case .integer(let x):
            try container.encode(x)
        case .integerMap(let x):
            try container.encode(x)
        case .nullArray(let x):
            try container.encode(x)
        }
    }
}

enum Unguentarium: Codable {
    case integer(Int)
    case nullArray([JSONNull?])
    case null

    init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let x = try? container.decode(Int.self) {
            self = .integer(x)
            return
        }
        if let x = try? container.decode([JSONNull?].self) {
            self = .nullArray(x)
            return
        }
        if container.decodeNil() {
            self = .null
            return
        }
        throw DecodingError.typeMismatch(Unguentarium.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Wrong type for Unguentarium"))
    }

    func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case .integer(let x):
            try container.encode(x)
        case .nullArray(let x):
            try container.encode(x)
        case .null:
            try container.encodeNil()
        }
    }
}

enum UnimpeachablyUnion: Codable {
    case bool(Bool)
    case unimpeachablyClass(UnimpeachablyClass)

    init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let x = try? container.decode(Bool.self) {
            self = .bool(x)
            return
        }
        if let x = try? container.decode(UnimpeachablyClass.self) {
            self = .unimpeachablyClass(x)
            return
        }
        throw DecodingError.typeMismatch(UnimpeachablyUnion.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Wrong type for UnimpeachablyUnion"))
    }

    func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case .bool(let x):
            try container.encode(x)
        case .unimpeachablyClass(let x):
            try container.encode(x)
        }
    }
}

class UnimpeachablyClass: Codable {
    let acerin, bobadil: Int?
    let catharticalness: Double?
    let chirotherium, chlorophylligenous, conversational, demiowl: Int?
    let disdiapason: String?
    let ectorhinal, gamblesomeness: Int?
    let homocerc: Bool?
    let irrorate, kindergartening, lateritic, mespil: Int?
    let misconfiguration: Int?
    let nonbookish: JSONNull?
    let planometry, quiina, robert, rot: Int?
    let subcinctorium, tussocker, ultraproud, unsuggestedness: Int?

    enum CodingKeys: String, CodingKey {
        case acerin
        case bobadil = "Bobadil"
        case catharticalness
        case chirotherium = "Chirotherium"
        case chlorophylligenous, conversational, demiowl, disdiapason, ectorhinal, gamblesomeness, homocerc, irrorate, kindergartening, lateritic, mespil, misconfiguration, nonbookish, planometry
        case quiina = "Quiina"
        case robert = "Robert"
        case rot, subcinctorium, tussocker, ultraproud, unsuggestedness
    }

    init(acerin: Int?, bobadil: Int?, catharticalness: Double?, chirotherium: Int?, chlorophylligenous: Int?, conversational: Int?, demiowl: Int?, disdiapason: String?, ectorhinal: Int?, gamblesomeness: Int?, homocerc: Bool?, irrorate: Int?, kindergartening: Int?, lateritic: Int?, mespil: Int?, misconfiguration: Int?, nonbookish: JSONNull?, planometry: Int?, quiina: Int?, robert: Int?, rot: Int?, subcinctorium: Int?, tussocker: Int?, ultraproud: Int?, unsuggestedness: Int?) {
        self.acerin = acerin
        self.bobadil = bobadil
        self.catharticalness = catharticalness
        self.chirotherium = chirotherium
        self.chlorophylligenous = chlorophylligenous
        self.conversational = conversational
        self.demiowl = demiowl
        self.disdiapason = disdiapason
        self.ectorhinal = ectorhinal
        self.gamblesomeness = gamblesomeness
        self.homocerc = homocerc
        self.irrorate = irrorate
        self.kindergartening = kindergartening
        self.lateritic = lateritic
        self.mespil = mespil
        self.misconfiguration = misconfiguration
        self.nonbookish = nonbookish
        self.planometry = planometry
        self.quiina = quiina
        self.robert = robert
        self.rot = rot
        self.subcinctorium = subcinctorium
        self.tussocker = tussocker
        self.ultraproud = ultraproud
        self.unsuggestedness = unsuggestedness
    }
}

enum Unmortgaged: Codable {
    case double(Double)
    case integerMap([String: Int])
    case null

    init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let x = try? container.decode(Double.self) {
            self = .double(x)
            return
        }
        if let x = try? container.decode([String: Int].self) {
            self = .integerMap(x)
            return
        }
        if container.decodeNil() {
            self = .null
            return
        }
        throw DecodingError.typeMismatch(Unmortgaged.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Wrong type for Unmortgaged"))
    }

    func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case .double(let x):
            try container.encode(x)
        case .integerMap(let x):
            try container.encode(x)
        case .null:
            try container.encodeNil()
        }
    }
}

enum Unobstructed: Codable {
    case integer(Int)
    case rebeccaClass(RebeccaClass)
    case null

    init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let x = try? container.decode(Int.self) {
            self = .integer(x)
            return
        }
        if let x = try? container.decode(RebeccaClass.self) {
            self = .rebeccaClass(x)
            return
        }
        if container.decodeNil() {
            self = .null
            return
        }
        throw DecodingError.typeMismatch(Unobstructed.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Wrong type for Unobstructed"))
    }

    func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case .integer(let x):
            try container.encode(x)
        case .rebeccaClass(let x):
            try container.encode(x)
        case .null:
            try container.encodeNil()
        }
    }
}

enum Unreceptivity: Codable {
    case integer(Int)
    case nullArray([JSONNull?])
    case string(String)

    init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let x = try? container.decode(Int.self) {
            self = .integer(x)
            return
        }
        if let x = try? container.decode(String.self) {
            self = .string(x)
            return
        }
        if let x = try? container.decode([JSONNull?].self) {
            self = .nullArray(x)
            return
        }
        throw DecodingError.typeMismatch(Unreceptivity.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Wrong type for Unreceptivity"))
    }

    func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case .integer(let x):
            try container.encode(x)
        case .nullArray(let x):
            try container.encode(x)
        case .string(let x):
            try container.encode(x)
        }
    }
}

enum Unsatisfactoriness: Codable {
    case bool(Bool)
    case integer(Int)
    case integerArray([Int])

    init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let x = try? container.decode(Bool.self) {
            self = .bool(x)
            return
        }
        if let x = try? container.decode(Int.self) {
            self = .integer(x)
            return
        }
        if let x = try? container.decode([Int].self) {
            self = .integerArray(x)
            return
        }
        throw DecodingError.typeMismatch(Unsatisfactoriness.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Wrong type for Unsatisfactoriness"))
    }

    func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case .bool(let x):
            try container.encode(x)
        case .integer(let x):
            try container.encode(x)
        case .integerArray(let x):
            try container.encode(x)
        }
    }
}

enum Unstressed: Codable {
    case bool(Bool)
    case nullMap([String: JSONNull?])
    case string(String)

    init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let x = try? container.decode(Bool.self) {
            self = .bool(x)
            return
        }
        if let x = try? container.decode(String.self) {
            self = .string(x)
            return
        }
        if let x = try? container.decode([String: JSONNull?].self) {
            self = .nullMap(x)
            return
        }
        throw DecodingError.typeMismatch(Unstressed.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Wrong type for Unstressed"))
    }

    func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case .bool(let x):
            try container.encode(x)
        case .nullMap(let x):
            try container.encode(x)
        case .string(let x):
            try container.encode(x)
        }
    }
}

enum Untasked: Codable {
    case double(Double)
    case integerMap([String: Int])
    case nullArray([JSONNull?])

    init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let x = try? container.decode(Double.self) {
            self = .double(x)
            return
        }
        if let x = try? container.decode([String: Int].self) {
            self = .integerMap(x)
            return
        }
        if let x = try? container.decode([JSONNull?].self) {
            self = .nullArray(x)
            return
        }
        throw DecodingError.typeMismatch(Untasked.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Wrong type for Untasked"))
    }

    func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case .double(let x):
            try container.encode(x)
        case .integerMap(let x):
            try container.encode(x)
        case .nullArray(let x):
            try container.encode(x)
        }
    }
}

enum Unvarying: Codable {
    case bool(Bool)
    case double(Double)
    case integerMap([String: Int])

    init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let x = try? container.decode(Bool.self) {
            self = .bool(x)
            return
        }
        if let x = try? container.decode(Double.self) {
            self = .double(x)
            return
        }
        if let x = try? container.decode([String: Int].self) {
            self = .integerMap(x)
            return
        }
        throw DecodingError.typeMismatch(Unvarying.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Wrong type for Unvarying"))
    }

    func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case .bool(let x):
            try container.encode(x)
        case .double(let x):
            try container.encode(x)
        case .integerMap(let x):
            try container.encode(x)
        }
    }
}

enum Vehemently: Codable {
    case bool(Bool)
    case nullArray([JSONNull?])
    case null

    init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let x = try? container.decode(Bool.self) {
            self = .bool(x)
            return
        }
        if let x = try? container.decode([JSONNull?].self) {
            self = .nullArray(x)
            return
        }
        if container.decodeNil() {
            self = .null
            return
        }
        throw DecodingError.typeMismatch(Vehemently.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Wrong type for Vehemently"))
    }

    func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case .bool(let x):
            try container.encode(x)
        case .nullArray(let x):
            try container.encode(x)
        case .null:
            try container.encodeNil()
        }
    }
}

enum Wrothy: Codable {
    case nullArray([JSONNull?])
    case nullMap([String: JSONNull?])

    init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let x = try? container.decode([String: JSONNull?].self) {
            self = .nullMap(x)
            return
        }
        if let x = try? container.decode([JSONNull?].self) {
            self = .nullArray(x)
            return
        }
        throw DecodingError.typeMismatch(Wrothy.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Wrong type for Wrothy"))
    }

    func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case .nullArray(let x):
            try container.encode(x)
        case .nullMap(let x):
            try container.encode(x)
        }
    }
}

// MARK: Convenience initializers

extension TopLevel {
    convenience init?(data: Data) throws {
        let me = try JSONDecoder().decode(TopLevel.self, from: data)
        self.init(abranchiata: me.abranchiata, academe: me.academe, acquirable: me.acquirable, aerometry: me.aerometry, alexin: me.alexin, alleviate: me.alleviate, amaas: me.amaas, ambassage: me.ambassage, amphithyron: me.amphithyron, andriana: me.andriana, ankee: me.ankee, annihilator: me.annihilator, annulose: me.annulose, ansarie: me.ansarie, aphasia: me.aphasia, asprawl: me.asprawl, attractive: me.attractive, barksome: me.barksome, bedesman: me.bedesman, belard: me.belard, bocking: me.bocking, brawlingly: me.brawlingly, brookie: me.brookie, bumboatman: me.bumboatman, bystreet: me.bystreet, calaverite: me.calaverite, catallactic: me.catallactic, cemental: me.cemental, centrodesmose: me.centrodesmose, cerograph: me.cerograph, chemotherapeutics: me.chemotherapeutics, chytridiaceae: me.chytridiaceae, cimelia: me.cimelia, citrated: me.citrated, clinodome: me.clinodome, coadjust: me.coadjust, consilience: me.consilience, constructor: me.constructor, continuative: me.continuative, credulity: me.credulity, creviced: me.creviced, cubiculum: me.cubiculum, deruralize: me.deruralize, diaereses: me.diaereses, discordia: me.discordia, dissolution: me.dissolution, downstroke: me.downstroke, electrotautomerism: me.electrotautomerism, eleutheromania: me.eleutheromania, encrust: me.encrust, endomyces: me.endomyces, entomoid: me.entomoid, epinephelidae: me.epinephelidae, epipaleolithic: me.epipaleolithic, eupatorium: me.eupatorium, expropriable: me.expropriable, faggingly: me.faggingly, fenks: me.fenks, flagmaking: me.flagmaking, fluorometer: me.fluorometer, fulsome: me.fulsome, fuzzy: me.fuzzy, gardenwards: me.gardenwards, generalissimo: me.generalissimo, gryphosaurus: me.gryphosaurus, habeas: me.habeas, hemicrystalline: me.hemicrystalline, hemocoele: me.hemocoele, hoister: me.hoister, hyperpiesis: me.hyperpiesis, hyppish: me.hyppish, idealizer: me.idealizer, incrustator: me.incrustator, intentiveness: me.intentiveness, interacinar: me.interacinar, intercorrelation: me.intercorrelation, jacutinga: me.jacutinga, juror: me.juror, kongoni: me.kongoni, koryak: me.koryak, ladronism: me.ladronism, landlubberly: me.landlubberly, lavinia: me.lavinia, listener: me.listener, lupus: me.lupus, maslin: me.maslin, monazite: me.monazite, monoliteral: me.monoliteral, monotheistically: me.monotheistically, montage: me.montage, moralness: me.moralness, mowra: me.mowra, mulishly: me.mulishly, myoscope: me.myoscope, nach: me.nach, neuromastic: me.neuromastic, noncontributing: me.noncontributing, nonnervous: me.nonnervous, nonvaluation: me.nonvaluation, occupationalist: me.occupationalist, oskar: me.oskar, outrival: me.outrival, paleographically: me.paleographically, pamphletwise: me.pamphletwise, pediatrics: me.pediatrics, perceptive: me.perceptive, piaculum: me.piaculum, piccadilly: me.piccadilly, piffler: me.piffler, pithful: me.pithful, placuntitis: me.placuntitis, plectopterous: me.plectopterous, pneumocele: me.pneumocele, poliorcetic: me.poliorcetic, poormaster: me.poormaster, potwhisky: me.potwhisky, practicalizer: me.practicalizer, prefreshman: me.prefreshman, prehensility: me.prehensility, prevoidance: me.prevoidance, probant: me.probant, protext: me.protext, protrusive: me.protrusive, pulpitism: me.pulpitism, pyodermia: me.pyodermia, quebrachine: me.quebrachine, querier: me.querier, rebarbative: me.rebarbative, rebecca: me.rebecca, reimagine: me.reimagine, ressaut: me.ressaut, retrocervical: me.retrocervical, revert: me.revert, rewrite: me.rewrite, rhomboganoidei: me.rhomboganoidei, rigsmal: me.rigsmal, ruellia: me.ruellia, saccoderm: me.saccoderm, santir: me.santir, saprophilous: me.saprophilous, saxten: me.saxten, scatty: me.scatty, school: me.school, scoffer: me.scoffer, scrampum: me.scrampum, semantic: me.semantic, serpentinic: me.serpentinic, shadowable: me.shadowable, shakespearolater: me.shakespearolater, sistering: me.sistering, staghunting: me.staghunting, stagmometer: me.stagmometer, stimulability: me.stimulability, strangleable: me.strangleable, strenuosity: me.strenuosity, svan: me.svan, tabaxir: me.tabaxir, talpiform: me.talpiform, thwack: me.thwack, to: me.to, tortricine: me.tortricine, truantcy: me.truantcy, turgesce: me.turgesce, unbeginning: me.unbeginning, underdunged: me.underdunged, undesirability: me.undesirability, unerasing: me.unerasing, unguentarium: me.unguentarium, unimpeachably: me.unimpeachably, unmortgaged: me.unmortgaged, unobstructed: me.unobstructed, unreceptivity: me.unreceptivity, unsatisfactoriness: me.unsatisfactoriness, unsecurity: me.unsecurity, unstressed: me.unstressed, untasked: me.untasked, unvarying: me.unvarying, vehemently: me.vehemently, warriorship: me.warriorship, wayao: me.wayao, whitepot: me.whitepot, wrothy: me.wrothy)
    }

    convenience init?(_ json: String, using encoding: String.Encoding = .utf8) throws {
        guard let data = json.data(using: encoding) else { return nil }
        try self.init(data: data)
    }

    convenience init?(fromURL url: String) throws {
        guard let url = URL(string: url) else { return nil }
        let data = try Data(contentsOf: url)
        try self.init(data: data)
    }

    func jsonData() throws -> Data {
        return try JSONEncoder().encode(self)
    }

    func jsonString() throws -> String? {
        return String(data: try self.jsonData(), encoding: .utf8)
    }
}

extension RebeccaClass {
    convenience init?(data: Data) throws {
        let me = try JSONDecoder().decode(RebeccaClass.self, from: data)
        self.init(catharticalness: me.catharticalness, chirotherium: me.chirotherium, disdiapason: me.disdiapason, homocerc: me.homocerc, nonbookish: me.nonbookish)
    }

    convenience init?(_ json: String, using encoding: String.Encoding = .utf8) throws {
        guard let data = json.data(using: encoding) else { return nil }
        try self.init(data: data)
    }

    convenience init?(fromURL url: String) throws {
        guard let url = URL(string: url) else { return nil }
        let data = try Data(contentsOf: url)
        try self.init(data: data)
    }

    func jsonData() throws -> Data {
        return try JSONEncoder().encode(self)
    }

    func jsonString() throws -> String? {
        return String(data: try self.jsonData(), encoding: .utf8)
    }
}

extension Amphithyron {
    convenience init?(data: Data) throws {
        let me = try JSONDecoder().decode(Amphithyron.self, from: data)
        self.init(akroasis: me.akroasis, antiphonical: me.antiphonical, basebred: me.basebred, catharticalness: me.catharticalness, chirotherium: me.chirotherium, conductometric: me.conductometric, disdiapason: me.disdiapason, ensilation: me.ensilation, eyebolt: me.eyebolt, fistulated: me.fistulated, heteropod: me.heteropod, homocerc: me.homocerc, juniperus: me.juniperus, labyrinthically: me.labyrinthically, martyrization: me.martyrization, mispolicy: me.mispolicy, multipara: me.multipara, nazirite: me.nazirite, nonbookish: me.nonbookish, possessorial: me.possessorial, shamed: me.shamed, shelfworn: me.shelfworn, stagnum: me.stagnum, those: me.those, undecimal: me.undecimal)
    }

    convenience init?(_ json: String, using encoding: String.Encoding = .utf8) throws {
        guard let data = json.data(using: encoding) else { return nil }
        try self.init(data: data)
    }

    convenience init?(fromURL url: String) throws {
        guard let url = URL(string: url) else { return nil }
        let data = try Data(contentsOf: url)
        try self.init(data: data)
    }

    func jsonData() throws -> Data {
        return try JSONEncoder().encode(self)
    }

    func jsonString() throws -> String? {
        return String(data: try self.jsonData(), encoding: .utf8)
    }
}

extension ChemotherapeuticClass {
    convenience init?(data: Data) throws {
        let me = try JSONDecoder().decode(ChemotherapeuticClass.self, from: data)
        self.init(angioneurotic: me.angioneurotic, availment: me.availment, bladelet: me.bladelet, catharticalness: me.catharticalness, caulis: me.caulis, chalcus: me.chalcus, chirotherium: me.chirotherium, disdiapason: me.disdiapason, enteradenological: me.enteradenological, homocerc: me.homocerc, imporosity: me.imporosity, insistently: me.insistently, intraparietal: me.intraparietal, ivied: me.ivied, maureen: me.maureen, nonbookish: me.nonbookish, nostochine: me.nostochine, nutcracker: me.nutcracker, ofttimes: me.ofttimes, phenocryst: me.phenocryst, precoincident: me.precoincident, ramiferous: me.ramiferous, stagmometer: me.stagmometer, tetherball: me.tetherball, unshy: me.unshy)
    }

    convenience init?(_ json: String, using encoding: String.Encoding = .utf8) throws {
        guard let data = json.data(using: encoding) else { return nil }
        try self.init(data: data)
    }

    convenience init?(fromURL url: String) throws {
        guard let url = URL(string: url) else { return nil }
        let data = try Data(contentsOf: url)
        try self.init(data: data)
    }

    func jsonData() throws -> Data {
        return try JSONEncoder().encode(self)
    }

    func jsonString() throws -> String? {
        return String(data: try self.jsonData(), encoding: .utf8)
    }
}

extension CoadjustClass {
    convenience init?(data: Data) throws {
        let me = try JSONDecoder().decode(CoadjustClass.self, from: data)
        self.init(amidosulphonal: me.amidosulphonal, benny: me.benny, catharticalness: me.catharticalness, chirotherium: me.chirotherium, disdiapason: me.disdiapason, ensnare: me.ensnare, homocerc: me.homocerc, hybridizer: me.hybridizer, leastwise: me.leastwise, lof: me.lof, monkhood: me.monkhood, netherlandish: me.netherlandish, nonbookish: me.nonbookish, peonism: me.peonism, phonelescope: me.phonelescope, porphyrogeniture: me.porphyrogeniture, preindemnify: me.preindemnify, rosal: me.rosal, scalenous: me.scalenous, scopine: me.scopine, sedaceae: me.sedaceae, suberinize: me.suberinize, symbiot: me.symbiot, tablefellow: me.tablefellow, unchargeable: me.unchargeable)
    }

    convenience init?(_ json: String, using encoding: String.Encoding = .utf8) throws {
        guard let data = json.data(using: encoding) else { return nil }
        try self.init(data: data)
    }

    convenience init?(fromURL url: String) throws {
        guard let url = URL(string: url) else { return nil }
        let data = try Data(contentsOf: url)
        try self.init(data: data)
    }

    func jsonData() throws -> Data {
        return try JSONEncoder().encode(self)
    }

    func jsonString() throws -> String? {
        return String(data: try self.jsonData(), encoding: .utf8)
    }
}

extension DiscordiaClass {
    convenience init?(data: Data) throws {
        let me = try JSONDecoder().decode(DiscordiaClass.self, from: data)
        self.init(altaic: me.altaic, amoristic: me.amoristic, blennophthalmia: me.blennophthalmia, catharticalness: me.catharticalness, chirotherium: me.chirotherium, disciplinability: me.disciplinability, disdiapason: me.disdiapason, goofer: me.goofer, homocerc: me.homocerc, laryngograph: me.laryngograph, leucitis: me.leucitis, lymphocyst: me.lymphocyst, microcosmology: me.microcosmology, nauseation: me.nauseation, nonbookish: me.nonbookish, patarin: me.patarin, preliberal: me.preliberal, prettifier: me.prettifier, rangework: me.rangework, redient: me.redient, subfusiform: me.subfusiform, suicidical: me.suicidical, swow: me.swow, wastrel: me.wastrel, wingle: me.wingle)
    }

    convenience init?(_ json: String, using encoding: String.Encoding = .utf8) throws {
        guard let data = json.data(using: encoding) else { return nil }
        try self.init(data: data)
    }

    convenience init?(fromURL url: String) throws {
        guard let url = URL(string: url) else { return nil }
        let data = try Data(contentsOf: url)
        try self.init(data: data)
    }

    func jsonData() throws -> Data {
        return try JSONEncoder().encode(self)
    }

    func jsonString() throws -> String? {
        return String(data: try self.jsonData(), encoding: .utf8)
    }
}

extension HemocoeleClass {
    convenience init?(data: Data) throws {
        let me = try JSONDecoder().decode(HemocoeleClass.self, from: data)
        self.init(acrogamy: me.acrogamy, amelification: me.amelification, autobiographic: me.autobiographic, berat: me.berat, catharticalness: me.catharticalness, chirotherium: me.chirotherium, disdiapason: me.disdiapason, disproportionably: me.disproportionably, erythrite: me.erythrite, graphic: me.graphic, hepatological: me.hepatological, homocerc: me.homocerc, incommensurably: me.incommensurably, misaffirm: me.misaffirm, nonbookish: me.nonbookish, pocketbook: me.pocketbook, sclerometric: me.sclerometric, stambouline: me.stambouline, stickpin: me.stickpin, tubulure: me.tubulure, undelated: me.undelated, unsalt: me.unsalt, untutelar: me.untutelar, vagrant: me.vagrant, walt: me.walt)
    }

    convenience init?(_ json: String, using encoding: String.Encoding = .utf8) throws {
        guard let data = json.data(using: encoding) else { return nil }
        try self.init(data: data)
    }

    convenience init?(fromURL url: String) throws {
        guard let url = URL(string: url) else { return nil }
        let data = try Data(contentsOf: url)
        try self.init(data: data)
    }

    func jsonData() throws -> Data {
        return try JSONEncoder().encode(self)
    }

    func jsonString() throws -> String? {
        return String(data: try self.jsonData(), encoding: .utf8)
    }
}

extension Interacinar {
    convenience init?(data: Data) throws {
        let me = try JSONDecoder().decode(Interacinar.self, from: data)
        self.init(assapan: me.assapan, benefactorship: me.benefactorship, triseriatim: me.triseriatim, tubbing: me.tubbing, untrimmed: me.untrimmed)
    }

    convenience init?(_ json: String, using encoding: String.Encoding = .utf8) throws {
        guard let data = json.data(using: encoding) else { return nil }
        try self.init(data: data)
    }

    convenience init?(fromURL url: String) throws {
        guard let url = URL(string: url) else { return nil }
        let data = try Data(contentsOf: url)
        try self.init(data: data)
    }

    func jsonData() throws -> Data {
        return try JSONEncoder().encode(self)
    }

    func jsonString() throws -> String? {
        return String(data: try self.jsonData(), encoding: .utf8)
    }
}

extension LaviniaClass {
    convenience init?(data: Data) throws {
        let me = try JSONDecoder().decode(LaviniaClass.self, from: data)
        self.init(agitable: me.agitable, asininity: me.asininity, benefiter: me.benefiter, bronzelike: me.bronzelike, catharticalness: me.catharticalness, chirotherium: me.chirotherium, cholesteatomatous: me.cholesteatomatous, deprivement: me.deprivement, disdiapason: me.disdiapason, flippantness: me.flippantness, fogproof: me.fogproof, homocerc: me.homocerc, merrymeeting: me.merrymeeting, nonbookish: me.nonbookish, overcareful: me.overcareful, panaris: me.panaris, preacceptance: me.preacceptance, quinoxaline: me.quinoxaline, sig: me.sig, superconfusion: me.superconfusion, tacana: me.tacana, tillotter: me.tillotter, tranquillize: me.tranquillize, unquestionable: me.unquestionable, uproute: me.uproute)
    }

    convenience init?(_ json: String, using encoding: String.Encoding = .utf8) throws {
        guard let data = json.data(using: encoding) else { return nil }
        try self.init(data: data)
    }

    convenience init?(fromURL url: String) throws {
        guard let url = URL(string: url) else { return nil }
        let data = try Data(contentsOf: url)
        try self.init(data: data)
    }

    func jsonData() throws -> Data {
        return try JSONEncoder().encode(self)
    }

    func jsonString() throws -> String? {
        return String(data: try self.jsonData(), encoding: .utf8)
    }
}

extension LupusClass {
    convenience init?(data: Data) throws {
        let me = try JSONDecoder().decode(LupusClass.self, from: data)
        self.init(catharticalness: me.catharticalness, chirotherium: me.chirotherium, chlorioninae: me.chlorioninae, corvinae: me.corvinae, crassina: me.crassina, disdiapason: me.disdiapason, exiguity: me.exiguity, farcist: me.farcist, holographical: me.holographical, homocerc: me.homocerc, ichthyophagan: me.ichthyophagan, implacable: me.implacable, nonbookish: me.nonbookish, outshiner: me.outshiner, overweather: me.overweather, protonegroid: me.protonegroid, shallowish: me.shallowish, snoke: me.snoke, snout: me.snout, surveillance: me.surveillance, threshingtime: me.threshingtime, thysanocarpus: me.thysanocarpus, unsignificantly: me.unsignificantly, unsnap: me.unsnap, vendible: me.vendible)
    }

    convenience init?(_ json: String, using encoding: String.Encoding = .utf8) throws {
        guard let data = json.data(using: encoding) else { return nil }
        try self.init(data: data)
    }

    convenience init?(fromURL url: String) throws {
        guard let url = URL(string: url) else { return nil }
        let data = try Data(contentsOf: url)
        try self.init(data: data)
    }

    func jsonData() throws -> Data {
        return try JSONEncoder().encode(self)
    }

    func jsonString() throws -> String? {
        return String(data: try self.jsonData(), encoding: .utf8)
    }
}

extension Maslin {
    convenience init?(data: Data) throws {
        let me = try JSONDecoder().decode(Maslin.self, from: data)
        self.init(alicant: me.alicant, antiatonement: me.antiatonement, anticorrosive: me.anticorrosive, aphidozer: me.aphidozer, bakuninist: me.bakuninist, be: me.be, catharticalness: me.catharticalness, chirotherium: me.chirotherium, chub: me.chub, cuprosilicon: me.cuprosilicon, curtailedly: me.curtailedly, dellenite: me.dellenite, dimitry: me.dimitry, disdiapason: me.disdiapason, edifying: me.edifying, ethmoiditis: me.ethmoiditis, gastralgy: me.gastralgy, goatherd: me.goatherd, hammerdress: me.hammerdress, hangfire: me.hangfire, homocerc: me.homocerc, lacunosity: me.lacunosity, longiloquence: me.longiloquence, mameliere: me.mameliere, motherless: me.motherless, nonbookish: me.nonbookish, noncorrodible: me.noncorrodible, nonsensicality: me.nonsensicality, oafishly: me.oafishly, pfund: me.pfund, preadvisory: me.preadvisory, retroflexed: me.retroflexed, saccharulmic: me.saccharulmic, scowlful: me.scowlful, secluded: me.secluded, slackage: me.slackage, sphaeridial: me.sphaeridial, spondulics: me.spondulics, subsecive: me.subsecive, swellmobsman: me.swellmobsman, trachyglossate: me.trachyglossate, trialogue: me.trialogue, unassuaged: me.unassuaged, ungross: me.ungross, unjudiciously: me.unjudiciously)
    }

    convenience init?(_ json: String, using encoding: String.Encoding = .utf8) throws {
        guard let data = json.data(using: encoding) else { return nil }
        try self.init(data: data)
    }

    convenience init?(fromURL url: String) throws {
        guard let url = URL(string: url) else { return nil }
        let data = try Data(contentsOf: url)
        try self.init(data: data)
    }

    func jsonData() throws -> Data {
        return try JSONEncoder().encode(self)
    }

    func jsonString() throws -> String? {
        return String(data: try self.jsonData(), encoding: .utf8)
    }
}

extension MonotheisticallyClass {
    convenience init?(data: Data) throws {
        let me = try JSONDecoder().decode(MonotheisticallyClass.self, from: data)
        self.init(blaspheme: me.blaspheme, catharticalness: me.catharticalness, celiosalpingectomy: me.celiosalpingectomy, chirotherium: me.chirotherium, consummativeness: me.consummativeness, disdiapason: me.disdiapason, egestive: me.egestive, enchylema: me.enchylema, gasconade: me.gasconade, holidayer: me.holidayer, homocerc: me.homocerc, intuitionalism: me.intuitionalism, lophiostomate: me.lophiostomate, nonbookish: me.nonbookish, nonvolition: me.nonvolition, palatableness: me.palatableness, pimpery: me.pimpery, previolation: me.previolation, reconveyance: me.reconveyance, registership: me.registership, rhyacolite: me.rhyacolite, smithereens: me.smithereens, superedification: me.superedification, trust: me.trust, whitestone: me.whitestone)
    }

    convenience init?(_ json: String, using encoding: String.Encoding = .utf8) throws {
        guard let data = json.data(using: encoding) else { return nil }
        try self.init(data: data)
    }

    convenience init?(fromURL url: String) throws {
        guard let url = URL(string: url) else { return nil }
        let data = try Data(contentsOf: url)
        try self.init(data: data)
    }

    func jsonData() throws -> Data {
        return try JSONEncoder().encode(self)
    }

    func jsonString() throws -> String? {
        return String(data: try self.jsonData(), encoding: .utf8)
    }
}

extension Noncontributing {
    convenience init?(data: Data) throws {
        let me = try JSONDecoder().decode(Noncontributing.self, from: data)
        self.init(estevin: me.estevin, jolterhead: me.jolterhead, sauternes: me.sauternes, sparsely: me.sparsely, unrequested: me.unrequested)
    }

    convenience init?(_ json: String, using encoding: String.Encoding = .utf8) throws {
        guard let data = json.data(using: encoding) else { return nil }
        try self.init(data: data)
    }

    convenience init?(fromURL url: String) throws {
        guard let url = URL(string: url) else { return nil }
        let data = try Data(contentsOf: url)
        try self.init(data: data)
    }

    func jsonData() throws -> Data {
        return try JSONEncoder().encode(self)
    }

    func jsonString() throws -> String? {
        return String(data: try self.jsonData(), encoding: .utf8)
    }
}

extension PiaculumClass {
    convenience init?(data: Data) throws {
        let me = try JSONDecoder().decode(PiaculumClass.self, from: data)
        self.init(alada: me.alada, amphistomous: me.amphistomous, boysenberry: me.boysenberry, catharticalness: me.catharticalness, chirotherium: me.chirotherium, decardinalize: me.decardinalize, discouragement: me.discouragement, disdiapason: me.disdiapason, doitrified: me.doitrified, hexaspermous: me.hexaspermous, homocerc: me.homocerc, insinking: me.insinking, loathfulness: me.loathfulness, miasmatical: me.miasmatical, neurofibril: me.neurofibril, nonbookish: me.nonbookish, phonendoscope: me.phonendoscope, pilferment: me.pilferment, predismissory: me.predismissory, preinscription: me.preinscription, quotative: me.quotative, sienna: me.sienna, thorax: me.thorax, yachting: me.yachting, zipper: me.zipper)
    }

    convenience init?(_ json: String, using encoding: String.Encoding = .utf8) throws {
        guard let data = json.data(using: encoding) else { return nil }
        try self.init(data: data)
    }

    convenience init?(fromURL url: String) throws {
        guard let url = URL(string: url) else { return nil }
        let data = try Data(contentsOf: url)
        try self.init(data: data)
    }

    func jsonData() throws -> Data {
        return try JSONEncoder().encode(self)
    }

    func jsonString() throws -> String? {
        return String(data: try self.jsonData(), encoding: .utf8)
    }
}

extension Pneumocele {
    convenience init?(data: Data) throws {
        let me = try JSONDecoder().decode(Pneumocele.self, from: data)
        self.init(carbonarism: me.carbonarism, catharticalness: me.catharticalness, chirotherium: me.chirotherium, cineolic: me.cineolic, cobbly: me.cobbly, conchyliferous: me.conchyliferous, congregation: me.congregation, disdiapason: me.disdiapason, enterotomy: me.enterotomy, entophytal: me.entophytal, fewtrils: me.fewtrils, herem: me.herem, homocerc: me.homocerc, koniga: me.koniga, meticulosity: me.meticulosity, micky: me.micky, mismarriage: me.mismarriage, neurotrophic: me.neurotrophic, nonbookish: me.nonbookish, persuasively: me.persuasively, replaceable: me.replaceable, silex: me.silex, taillight: me.taillight, unjealous: me.unjealous, visitorial: me.visitorial)
    }

    convenience init?(_ json: String, using encoding: String.Encoding = .utf8) throws {
        guard let data = json.data(using: encoding) else { return nil }
        try self.init(data: data)
    }

    convenience init?(fromURL url: String) throws {
        guard let url = URL(string: url) else { return nil }
        let data = try Data(contentsOf: url)
        try self.init(data: data)
    }

    func jsonData() throws -> Data {
        return try JSONEncoder().encode(self)
    }

    func jsonString() throws -> String? {
        return String(data: try self.jsonData(), encoding: .utf8)
    }
}

extension Reimagine {
    convenience init?(data: Data) throws {
        let me = try JSONDecoder().decode(Reimagine.self, from: data)
        self.init(adducible: me.adducible, anabolin: me.anabolin, brainy: me.brainy, catharticalness: me.catharticalness, chirotherium: me.chirotherium, chrysamine: me.chrysamine, disdiapason: me.disdiapason, fluxweed: me.fluxweed, glaucine: me.glaucine, grobianism: me.grobianism, hermo: me.hermo, hieroglyphist: me.hieroglyphist, homocerc: me.homocerc, icteroid: me.icteroid, immortal: me.immortal, impetulant: me.impetulant, irrigate: me.irrigate, myxedema: me.myxedema, nonbookish: me.nonbookish, onyx: me.onyx, repasser: me.repasser, septomarginal: me.septomarginal, subdie: me.subdie, tibiometatarsal: me.tibiometatarsal, waltzlike: me.waltzlike)
    }

    convenience init?(_ json: String, using encoding: String.Encoding = .utf8) throws {
        guard let data = json.data(using: encoding) else { return nil }
        try self.init(data: data)
    }

    convenience init?(fromURL url: String) throws {
        guard let url = URL(string: url) else { return nil }
        let data = try Data(contentsOf: url)
        try self.init(data: data)
    }

    func jsonData() throws -> Data {
        return try JSONEncoder().encode(self)
    }

    func jsonString() throws -> String? {
        return String(data: try self.jsonData(), encoding: .utf8)
    }
}

extension SaxtenClass {
    convenience init?(data: Data) throws {
        let me = try JSONDecoder().decode(SaxtenClass.self, from: data)
        self.init(algarrobilla: me.algarrobilla, bowgrace: me.bowgrace, catharticalness: me.catharticalness, centaurid: me.centaurid, chirotherium: me.chirotherium, disdiapason: me.disdiapason, flix: me.flix, germanely: me.germanely, homocerc: me.homocerc, inhume: me.inhume, lepidote: me.lepidote, megalochirous: me.megalochirous, ninepenny: me.ninepenny, nonbookish: me.nonbookish, nondeist: me.nondeist, nymphaeaceous: me.nymphaeaceous, parietofrontal: me.parietofrontal, sancyite: me.sancyite, subjectivist: me.subjectivist, tibiad: me.tibiad, transonic: me.transonic, tripetalous: me.tripetalous, trunchman: me.trunchman, urger: me.urger, withdrawnness: me.withdrawnness)
    }

    convenience init?(_ json: String, using encoding: String.Encoding = .utf8) throws {
        guard let data = json.data(using: encoding) else { return nil }
        try self.init(data: data)
    }

    convenience init?(fromURL url: String) throws {
        guard let url = URL(string: url) else { return nil }
        let data = try Data(contentsOf: url)
        try self.init(data: data)
    }

    func jsonData() throws -> Data {
        return try JSONEncoder().encode(self)
    }

    func jsonString() throws -> String? {
        return String(data: try self.jsonData(), encoding: .utf8)
    }
}

extension Staghunting {
    convenience init?(data: Data) throws {
        let me = try JSONDecoder().decode(Staghunting.self, from: data)
        self.init(calorimetric: me.calorimetric, canid: me.canid, catharticalness: me.catharticalness, chirotherium: me.chirotherium, disdiapason: me.disdiapason, ditriglyphic: me.ditriglyphic, floriferousness: me.floriferousness, gamelike: me.gamelike, grig: me.grig, homocerc: me.homocerc, interloan: me.interloan, lithotomy: me.lithotomy, loric: me.loric, membranocoriaceous: me.membranocoriaceous, membranogenic: me.membranogenic, nonbookish: me.nonbookish, overtrump: me.overtrump, scotino: me.scotino, seasonable: me.seasonable, sephen: me.sephen, stigmarioid: me.stigmarioid, tired: me.tired, trifid: me.trifid, undefeatedly: me.undefeatedly, ungirlish: me.ungirlish)
    }

    convenience init?(_ json: String, using encoding: String.Encoding = .utf8) throws {
        guard let data = json.data(using: encoding) else { return nil }
        try self.init(data: data)
    }

    convenience init?(fromURL url: String) throws {
        guard let url = URL(string: url) else { return nil }
        let data = try Data(contentsOf: url)
        try self.init(data: data)
    }

    func jsonData() throws -> Data {
        return try JSONEncoder().encode(self)
    }

    func jsonString() throws -> String? {
        return String(data: try self.jsonData(), encoding: .utf8)
    }
}

extension StrenuosityClass {
    convenience init?(data: Data) throws {
        let me = try JSONDecoder().decode(StrenuosityClass.self, from: data)
        self.init(bliss: me.bliss, buccate: me.buccate, bulletproof: me.bulletproof, catharticalness: me.catharticalness, chirotherium: me.chirotherium, crumblingness: me.crumblingness, disdiapason: me.disdiapason, engagedly: me.engagedly, fightable: me.fightable, hoariness: me.hoariness, homocerc: me.homocerc, hypopodium: me.hypopodium, luxurist: me.luxurist, mechanician: me.mechanician, nonbookish: me.nonbookish, onopordon: me.onopordon, podgily: me.podgily, reformableness: me.reformableness, scatterbrains: me.scatterbrains, seminuria: me.seminuria, sodomite: me.sodomite, tramp: me.tramp, undueness: me.undueness, worthily: me.worthily, yankeeist: me.yankeeist)
    }

    convenience init?(_ json: String, using encoding: String.Encoding = .utf8) throws {
        guard let data = json.data(using: encoding) else { return nil }
        try self.init(data: data)
    }

    convenience init?(fromURL url: String) throws {
        guard let url = URL(string: url) else { return nil }
        let data = try Data(contentsOf: url)
        try self.init(data: data)
    }

    func jsonData() throws -> Data {
        return try JSONEncoder().encode(self)
    }

    func jsonString() throws -> String? {
        return String(data: try self.jsonData(), encoding: .utf8)
    }
}

extension TruantcyClass {
    convenience init?(data: Data) throws {
        let me = try JSONDecoder().decode(TruantcyClass.self, from: data)
        self.init(alfiona: me.alfiona, ascaridiasis: me.ascaridiasis, bungey: me.bungey, catharticalness: me.catharticalness, ceroxyle: me.ceroxyle, chirotherium: me.chirotherium, chorology: me.chorology, disdiapason: me.disdiapason, enmarble: me.enmarble, epeira: me.epeira, eurylaimi: me.eurylaimi, germination: me.germination, hallelujah: me.hallelujah, homocerc: me.homocerc, lev: me.lev, mouthing: me.mouthing, nonbookish: me.nonbookish, philliloo: me.philliloo, planetal: me.planetal, poney: me.poney, punctualist: me.punctualist, returnlessly: me.returnlessly, skelder: me.skelder, windwaywardly: me.windwaywardly, yuman: me.yuman)
    }

    convenience init?(_ json: String, using encoding: String.Encoding = .utf8) throws {
        guard let data = json.data(using: encoding) else { return nil }
        try self.init(data: data)
    }

    convenience init?(fromURL url: String) throws {
        guard let url = URL(string: url) else { return nil }
        let data = try Data(contentsOf: url)
        try self.init(data: data)
    }

    func jsonData() throws -> Data {
        return try JSONEncoder().encode(self)
    }

    func jsonString() throws -> String? {
        return String(data: try self.jsonData(), encoding: .utf8)
    }
}

extension UnimpeachablyClass {
    convenience init?(data: Data) throws {
        let me = try JSONDecoder().decode(UnimpeachablyClass.self, from: data)
        self.init(acerin: me.acerin, bobadil: me.bobadil, catharticalness: me.catharticalness, chirotherium: me.chirotherium, chlorophylligenous: me.chlorophylligenous, conversational: me.conversational, demiowl: me.demiowl, disdiapason: me.disdiapason, ectorhinal: me.ectorhinal, gamblesomeness: me.gamblesomeness, homocerc: me.homocerc, irrorate: me.irrorate, kindergartening: me.kindergartening, lateritic: me.lateritic, mespil: me.mespil, misconfiguration: me.misconfiguration, nonbookish: me.nonbookish, planometry: me.planometry, quiina: me.quiina, robert: me.robert, rot: me.rot, subcinctorium: me.subcinctorium, tussocker: me.tussocker, ultraproud: me.ultraproud, unsuggestedness: me.unsuggestedness)
    }

    convenience init?(_ json: String, using encoding: String.Encoding = .utf8) throws {
        guard let data = json.data(using: encoding) else { return nil }
        try self.init(data: data)
    }

    convenience init?(fromURL url: String) throws {
        guard let url = URL(string: url) else { return nil }
        let data = try Data(contentsOf: url)
        try self.init(data: data)
    }

    func jsonData() throws -> Data {
        return try JSONEncoder().encode(self)
    }

    func jsonString() throws -> String? {
        return String(data: try self.jsonData(), encoding: .utf8)
    }
}

// MARK: Encode/decode helpers

class JSONNull: Codable {
    public init() {}

    public required init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if !container.decodeNil() {
            throw DecodingError.typeMismatch(JSONNull.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Wrong type for JSONNull"))
        }
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encodeNil()
    }
}
